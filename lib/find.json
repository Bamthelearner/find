{"transactions":{"bid":"import FIND from 0xFIND\nimport FungibleToken from 0xFungibleToken\nimport FUSD from 0xFUSD\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet vaultRef = account.borrow<&FUSD.Vault>(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the owner's Vault!\")\n\t\t \n\t\tlet fusdReceiver = account.getCapability<&{FungibleToken.Receiver}>(/public/fusdReceiver)\n\n\t\tlet leaseCollection = account.getCapability<&FIND.LeaseCollection{FIND.LeaseCollectionPublic}>(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.unlink(FIND.LeasePublicPath)\n\t\t\tdestroy <- account.load<@AnyResource>(from:FIND.LeaseStoragePath)\n\t\t\taccount.save(<- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link<&FIND.LeaseCollection{FIND.LeaseCollectionPublic}>( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability<&FIND.BidCollection{FIND.BidCollectionPublic}>(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.unlink(FIND.BidPublicPath)\n\t\t\tdestroy <- account.load<@AnyResource>(from:FIND.BidStoragePath)\n\t\t\taccount.save(<- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link<&FIND.BidCollection{FIND.BidCollectionPublic}>( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\n\t\tlet vault <- vaultRef.withdraw(amount: amount) as! @FUSD.Vault\n\t\tlet bids = account.borrow<&FIND.BidCollection>(from: FIND.BidStoragePath)!\n\t\tbids.bid(name: name, vault: <- vault)\n\n\t}\n}\n","cancelAuction":"import FIND from 0xFIND\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet finLeases= account.borrow<&FIND.LeaseCollection>(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.cancel(name)\n\n\t}\n}\n","cancelBid":"import FIND from 0xFIND\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\t\tlet bids = account.borrow<&FIND.BidCollection>(from: FIND.BidStoragePath)!\n\t\tbids.cancelBid(name)\n\t}\n}\n","clock":"import FIND from 0xFIND\n\ntransaction(clock: UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet adminClient=account.borrow<&FIND.AdminProxy>(from: FIND.AdminProxyStoragePath)!\n\t\tadminClient.advanceClock(clock)\n\n\t}\n}\n","create_profile":"import FungibleToken from 0xFungibleToken\nimport FUSD from 0xFUSD\nimport FIND from 0xFIND\nimport Profile from 0xProfile\n\n\n//really not sure on how to input links here.)\ntransaction(name: String) {\n\tprepare(acct: AuthAccount) {\n\t\t//if we do not have a profile it might be stored under a different address so we will just remove it\n\t\tlet profileCap = acct.getCapability<&{Profile.Public}>(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tacct.unlink(Profile.publicPath)\n\t\t\tdestroy <- acct.load<@AnyResource>(from:Profile.storagePath)\n\t\t}\n\n\t\tlet profile <-Profile.createUser(name:name, description: \"\", allowStoringFollowers:true, tags:[\"find\"])\n\n\t\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd <- FUSD.createEmptyVault()\n\t\t\tacct.save(<- fusd, to: /storage/fusdVault)\n\t\t\tacct.link<&FUSD.Vault{FungibleToken.Receiver}>( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\tacct.link<&FUSD.Vault{FungibleToken.Balance}>( /public/fusdBalance, target: /storage/fusdVault)\n\n\t\t\tlet fusdWallet=Profile.Wallet(\n\t\t\t\tname:\"FUSD\", \n\t\t\t\treceiver:acct.getCapability<&{FungibleToken.Receiver}>(/public/fusdReceiver),\n\t\t\t\tbalance:acct.getCapability<&{FungibleToken.Balance}>(/public/fusdBalance),\n\t\t\t\taccept: Type<@FUSD.Vault>(),\n\t\t\t\tnames: [\"fusd\", \"stablecoin\"]\n\t\t\t)\n\n\t\t\tprofile.addWallet(fusdWallet)\n\t\t}\n\n\t\tlet leaseCollection = acct.getCapability<&FIND.LeaseCollection{FIND.LeaseCollectionPublic}>(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\tacct.unlink(FIND.LeasePublicPath)\n\t\t\tdestroy <- acct.load<@AnyResource>(from:FIND.LeaseStoragePath)\n\t\t\tacct.save(<- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\tacct.link<&FIND.LeaseCollection{FIND.LeaseCollectionPublic}>( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type<&FIND.LeaseCollection{FIND.LeaseCollectionPublic}>(), [\"find\", \"leases\"]))\n\n\t\tlet bidCollection = acct.getCapability<&FIND.BidCollection{FIND.BidCollectionPublic}>(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\tacct.unlink(FIND.BidPublicPath)\n\t\t\tdestroy <- acct.load<@AnyResource>(from:FIND.BidStoragePath)\n\t\t\tacct.save(<- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\tacct.link<&FIND.BidCollection{FIND.BidCollectionPublic}>( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\t\tprofile.addCollection(Profile.ResourceCollection( \"FINDBids\", bidCollection, Type<&FIND.BidCollection{FIND.BidCollectionPublic}>(), [\"find\", \"bids\"]))\n\n\t\tacct.save(<-profile, to: Profile.storagePath)\n\t\tacct.link<&Profile.User{Profile.Public}>(Profile.publicPath, target: Profile.storagePath)\n\n\t\tlet p =acct.borrow<&Profile.User>(from:Profile.storagePath)!\n\t\tp.verify(\"test\")\n\t}\n}\n","delistAuction":"import FIND from 0xFIND\n\ntransaction(name: String) {\n\tprepare(acct: AuthAccount) {\n\t\tlet finLeases= acct.borrow<&FIND.LeaseCollection>(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.delistAuction(name)\n\t}\n}\n","delistSale":"import FIND from 0xFIND\n\ntransaction(name: String) {\n\tprepare(acct: AuthAccount) {\n\t\tlet finLeases= acct.borrow<&FIND.LeaseCollection>(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.delistSale(name)\n\t}\n}\n","edit_profile":"import FungibleToken from 0xFungibleToken\nimport FUSD from 0xFUSD\nimport FIND from 0xFIND\nimport Profile from 0xProfile\n\n\ntransaction(name:String, description: String, avatar: String, tags:[String], allowStoringFollowers: Bool, links: [{String: String}]) {\n\tprepare(acct: AuthAccount) {\n\n\t\tlet profile =acct.borrow<&Profile.User>(from:Profile.storagePath)!\n\n\t\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd <- FUSD.createEmptyVault()\n\t\t\tacct.save(<- fusd, to: /storage/fusdVault)\n\t\t\tacct.link<&FUSD.Vault{FungibleToken.Receiver}>( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\tacct.link<&FUSD.Vault{FungibleToken.Balance}>( /public/fusdBalance, target: /storage/fusdVault)\n\t\t\tlet fusdWallet=Profile.Wallet(\n\t\t\t\tname:\"FUSD\", \n\t\t\t\treceiver:acct.getCapability<&{FungibleToken.Receiver}>(/public/fusdReceiver),\n\t\t\t\tbalance:acct.getCapability<&{FungibleToken.Balance}>(/public/fusdBalance),\n\t\t\t\taccept: Type<@FUSD.Vault>(),\n\t\t\t\tnames: [\"fusd\", \"stablecoin\"]\n\t\t\t)\n\t\t\tprofile.addWallet(fusdWallet)\n\t\t}\n\n\t\tprofile.setName(name)\n\t\tprofile.setDescription(description)\n\t\tprofile.setAvatar(avatar)\n\n\t\tlet existingTags=profile.setTags(tags)\n\n\t\tlet oldLinks=profile.getLinks()\n\n\t\tfor link in links {\n\t\t\tif link[\"remove\"] == \"true\" {\n\t\t\t  profile.removeLink(link[\"title\"]!)\t\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tprofile.addLink(Profile.Link(title: link[\"title\"]!, type: link[\"type\"]!, url: link[\"url\"]!))\n\t\t}\n\t}\n}\n\n","fullfill":"import FIND from 0xFIND\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet finLeases= account.borrow<&FIND.LeaseCollection>(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.fullfill(name)\n\n\t}\n}\n","fullfill_auction":"import FIND from 0xFIND\n\ntransaction(owner: Address, name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet leaseCollection = getAccount(owner).getCapability<&FIND.LeaseCollection{FIND.LeaseCollectionPublic}>(FIND.LeasePublicPath)\n\t\tleaseCollection.borrow()!.fullfillAuction(name)\n\n\t}\n}\n","increaseBid":"import FIND from 0xFIND\nimport FungibleToken from 0xFungibleToken\nimport FUSD from 0xFUSD\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet vaultRef = account.borrow<&FUSD.Vault>(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the owner's Vault!\")\n\t\tlet seller=FIND.lookup(name)!.owner\n\t\t\n\t\tlet fusdReceiver = account.getCapability<&{FungibleToken.Receiver}>(/public/fusdReceiver)\n\n\t\tlet leaseCollection = account.getCapability<&FIND.LeaseCollection{FIND.LeaseCollectionPublic}>(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(<- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link<&FIND.LeaseCollection{FIND.LeaseCollectionPublic}>( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability<&FIND.BidCollection{FIND.BidCollectionPublic}>(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(<- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link<&FIND.BidCollection{FIND.BidCollectionPublic}>( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\n\t\tlet vault <- vaultRef.withdraw(amount: amount) as! @FUSD.Vault\n\t\tlet bids = account.borrow<&FIND.BidCollection>(from: FIND.BidStoragePath)!\n\t\tbids.increaseBid(name: name, vault: <- vault)\n\n\t}\n}\n","janitor":"\nimport FIND from 0xFIND\n\ntransaction(name: String) {\n\n    prepare(account: AuthAccount) {\n       FIND.janitor(name)\n    }\n}\n \n","listForAuction":"import FIND from 0xFIND\n\ntransaction(name: String, auctionStartPrice: UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64) {\n\tprepare(acct: AuthAccount) {\n\t\tlet finLeases= acct.borrow<&FIND.LeaseCollection>(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.listForAuction(name: name, auctionStartPrice: auctionStartPrice, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration,  auctionExtensionOnLateBid: auctionExtensionOnLateBid)\n\n\t}\n}\n","listForSale":"import FIND from 0xFIND\n\ntransaction(name: String, directSellPrice:UFix64) {\n\tprepare(acct: AuthAccount) {\n\t\tlet finLeases= acct.borrow<&FIND.LeaseCollection>(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.listForSale(name: name,  directSellPrice:directSellPrice)\n\t}\n}\n","mint_fusd":"\n\nimport FungibleToken from 0xFungibleToken\nimport FUSD from 0xFUSD\n\ntransaction(recipient: Address, amount: UFix64) {\n\tlet tokenAdmin: &FUSD.Administrator\n\tlet tokenReceiver: &{FungibleToken.Receiver}\n\n\tprepare(signer: AuthAccount) {\n\n\t\tself.tokenAdmin = signer\n\t\t.borrow<&FUSD.Administrator>(from: /storage/fusdAdmin)\n\t\t?? panic(\"Signer is not the token admin\")\n\n\t\tself.tokenReceiver = getAccount(recipient)\n\t\t.getCapability(/public/fusdReceiver)\n\t\t.borrow<&{FungibleToken.Receiver}>()\n\t\t?? panic(\"Unable to borrow receiver reference\")\n\t}\n\n\texecute {\n\n\n\n\t\tlet minter <- self.tokenAdmin.createNewMinter()\n\t\tlet mintedVault <- minter.mintTokens(amount: amount)\n\n\t\tself.tokenReceiver.deposit(from: <-mintedVault)\n\n\t\tdestroy minter\n\t}\n}\n","register":"import FungibleToken from 0xFungibleToken\nimport FUSD from 0xFUSD\nimport Profile from 0xProfile\nimport FIND from 0xFIND\n\n\ntransaction(name: String) {\n\tprepare(acct: AuthAccount) {\n\n\t\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd <- FUSD.createEmptyVault()\n\t\t\tacct.save(<- fusd, to: /storage/fusdVault)\n\t\t\tacct.link<&FUSD.Vault{FungibleToken.Receiver}>( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\tacct.link<&FUSD.Vault{FungibleToken.Balance}>( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = acct.getCapability<&FIND.LeaseCollection{FIND.LeaseCollectionPublic}>(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\tacct.unlink(FIND.LeasePublicPath)\n\t\t\tdestroy <- acct.load<@AnyResource>(from:FIND.LeaseStoragePath)\n\n\t\t\tacct.save(<- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\tacct.link<&FIND.LeaseCollection{FIND.LeaseCollectionPublic}>( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = acct.getCapability<&FIND.BidCollection{FIND.BidCollectionPublic}>(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\tacct.unlink(FIND.BidPublicPath)\n\t\t\tdestroy <- acct.load<@AnyResource>(from:FIND.BidStoragePath)\n\n\t\t\tacct.save(<- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\tacct.link<&FIND.BidCollection{FIND.BidCollectionPublic}>( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = acct.getCapability<&{Profile.Public}>(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tacct.unlink(Profile.publicPath)\n\t\t\tdestroy <- acct.load<@AnyResource>(from:Profile.storagePath)\n\n\t\t\tlet profile <-Profile.createUser(name:name, description: \"\", allowStoringFollowers:true, tags:[\"find\"])\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:acct.getCapability<&{FungibleToken.Balance}>(/public/fusdBalance), accept: Type<@FUSD.Vault>(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type<&FIND.LeaseCollection{FIND.LeaseCollectionPublic}>(), [\"find\", \"leases\"]))\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDBids\", bidCollection, Type<&FIND.BidCollection{FIND.BidCollectionPublic}>(), [\"find\", \"bids\"]))\n\n\t\t\tacct.save(<-profile, to: Profile.storagePath)\n\t\t\tacct.link<&Profile.User{Profile.Public}>(Profile.publicPath, target: Profile.storagePath)\n\t\t}\n\n\t\tlet price=FIND.calculateCost(name)\n\t\tlog(\"The cost for registering this name is \".concat(price.toString()))\n\n\t\tlet vaultRef = acct.borrow<&FUSD.Vault>(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the owner's Vault!\")\n\t\tlet payVault <- vaultRef.withdraw(amount: price) as! @FUSD.Vault\n\n\t\tlet leases=acct.borrow<&FIND.LeaseCollection>(from: FIND.LeaseStoragePath)!\n\t\tleases.register(name: name, vault: <- payVault)\n\t\n\n\t}\n}\n","registerAdmin":"\n\nimport FUSD from 0xFUSD\nimport FIND from 0xFIND\nimport Profile from 0xProfile\nimport FungibleToken from 0xFungibleToken\n\ntransaction(name: String, user: Address) {\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet userAccount=getAccount(user)\n\t\tlet profileCap = userAccount.getCapability<&{Profile.Public}>(Profile.publicPath)\n\t\tlet leaseCollectionCap=userAccount.getCapability<&FIND.LeaseCollection{FIND.LeaseCollectionPublic}>(FIND.LeasePublicPath)\n\n\t\tlet wallet=account.getCapability<&{FungibleToken.Receiver}>(/public/fusdReceiver)\n\t\tlet adminClient=account.borrow<&FIND.AdminProxy>(from: FIND.AdminProxyStoragePath)!\n\n\t\tlet vaultRef = account.borrow<&FUSD.Vault>(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the owner's Vault!\")\n\t\tlet payVault <- vaultRef.withdraw(amount: 5.0) as! @FUSD.Vault\n\n\t\tadminClient.register(name: name, vault: <- payVault, profile: profileCap, leases: leaseCollectionCap)\n\t}\n}\n\n","remove_profile":"import Profile from 0xProfile\n\ntransaction() {\n\tprepare(acct: AuthAccount) {\n\t\t\tacct.unlink(Profile.publicPath)\n\t\t\tdestroy <- acct.load<@AnyResource>(from:Profile.storagePath)\n\t}\n}\n","renew":"import FungibleToken from 0xFungibleToken\nimport FUSD from 0xFUSD\nimport Profile from 0xProfile\nimport FIND from 0xFIND\n\n\ntransaction(name: String) {\n\tprepare(acct: AuthAccount) {\n\n\t\tlet profileCap = acct.getCapability<&{Profile.Public}>(Profile.publicPath)\n\n\t\tlet price=FIND.calculateCost(name)\n\t\tlog(\"The cost for registering this name is \".concat(price.toString()))\n\n\t\tlet vaultRef = acct.borrow<&FUSD.Vault>(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the owner's Vault!\")\n\t\tlet payVault <- vaultRef.withdraw(amount: price) as! @FUSD.Vault\n\n\t\tlet finLeases= acct.borrow<&FIND.LeaseCollection>(from:FIND.LeaseStoragePath)!\n\t\tlog(\"STATUS PRE\")\n\t\tlet finToken= finLeases.borrow(name)\n\t\tlog(finToken.getLeaseExpireTime().toString())\n\t\tfinToken.extendLease(<- payVault)\n\t\tlog(\"STATUS POST\")\n\t\tlog(finToken.getLeaseExpireTime().toString())\n\n\t}\n}\n","reregister":"\nimport FungibleToken from 0xFungibleToken\nimport FUSD from 0xFUSD\nimport Profile from 0xProfile\nimport FIND from 0xFIND\n\n\ntransaction(name: String) {\n\n    prepare(account: AuthAccount) {\n\n\n        let profileCap = account.getCapability<&{Profile.Public}>(Profile.publicPath)\n\n        let price=FIND.calculateCost(name)\n        log(\"The cost for registering this name is \".concat(price.toString()))\n\n        let vaultRef = account.borrow<&FUSD.Vault>(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the owner's Vault!\")\n        let payVault <- vaultRef.withdraw(amount: price)\n\n        FIND.register(name: name, vault: <- payVault, profile: profileCap)\n\n        log(\"STATUS POST\")\n        log(FIND.status(name))\n\n    }\n\n}\n \n","send":"import FUSD from 0xFUSD\nimport FIND from 0xFIND\n\ntransaction(name: String, amount: UFix64) {\n\n    prepare(account: AuthAccount) {\n        let vaultRef = account.borrow<&FUSD.Vault>(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the owner's Vault!\")\n\n        log(\"Sending \".concat(amount.toString()).concat( \" to profile with name \").concat(name))\n        FIND.deposit(to: name, from: <- vaultRef.withdraw(amount: amount))\n    }\n\n}\n \n","setup_fin_1_create_client":"\nimport \"../contracts/FIND.cdc\"\n\n//set up the adminClient in the contract that will own the network\ntransaction() {\n\n\tprepare(account: AuthAccount) {\n\n\t\tif account.getCapability(FIND.AdminProxyPublicPath).check<&AnyResource>() {\n\t\t\taccount.unlink(FIND.AdminProxyPublicPath)\n\t\t\tdestroy <- account.load<@AnyResource>(from: FIND.AdminProxyStoragePath)\n\t\t}\n\t\taccount.save(<- FIND.createAdminProxyClient(), to:FIND.AdminProxyStoragePath)\n\t\taccount.link<&{FIND.AdminProxyClient}>(FIND.AdminProxyPublicPath, target: FIND.AdminProxyStoragePath)\n\n\t}\n}\n","setup_fin_2_register_client":"import \"../contracts/FIND.cdc\"\n\n\n//link together the administrator to the client, signed by the owner of the contract\ntransaction(ownerAddress: Address) {\n\n    //versus account\n    prepare(account: AuthAccount) {\n\n        let owner= getAccount(ownerAddress)\n        let client= owner.getCapability<&{FIND.AdminProxyClient}>(FIND.AdminProxyPublicPath)\n                .borrow() ?? panic(\"Could not borrow admin client\")\n\n        let network=account.getCapability<&FIND.Network>(FIND.NetworkPrivatePath)\n        client.addCapability(network)\n\n    }\n}\n \n","setup_fin_3_create_network":"\nimport FUSD from 0xFUSD\nimport FIND from 0xFIND\nimport FungibleToken from 0xFungibleToken\n\ntransaction() {\n\n\tprepare(account: AuthAccount) {\n\t\tlet wallet=account.getCapability<&{FungibleToken.Receiver}>(/public/fusdReceiver)\n\t\tif !wallet.check() {\n\t\t\tlet fusd <- FUSD.createEmptyVault()\n\t\t\taccount.save(<- fusd, to: /storage/fusdVault)\n\t\t\taccount.link<&FUSD.Vault{FungibleToken.Receiver}>( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\taccount.link<&FUSD.Vault{FungibleToken.Balance}>( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet adminClient=account.borrow<&FIND.AdminProxy>(from: FIND.AdminProxyStoragePath)!\n\t\tadminClient.setWallet(wallet)\n\t\tadminClient.setPublicEnabled(true)\n\t}\n}\n\n","startAuction":"import FIND from 0xFIND\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet finLeases= account.borrow<&FIND.LeaseCollection>(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.startAuction(name)\n\n\t}\n}\n","status":"\nimport FIND from 0xFIND\n\ntransaction(name: String) {\n\n    prepare(account: AuthAccount) {\n        let status=FIND.status(name)\n\t\t\t\tif status.status == FIND.LeaseStatus.LOCKED {\n\t\t\t\t\tpanic(\"locked\")\n\t\t\t\t}\n\t\t\t\tif status.status == FIND.LeaseStatus.FREE {\n\t\t\t\t\tpanic(\"free\")\n\t\t\t\t}\n    }\n\n}\n \n"},"scripts":{"address_status":"import FIND from 0xFIND\nimport Profile from 0xProfile\n\npub struct FINDReport{\n\tpub let profile:Profile.UserProfile?\n\tpub let bids: [FIND.BidInfo]\n\tpub let leases: [FIND.LeaseInformation]\n\n\tinit(profile: Profile.UserProfile?, bids: [FIND.BidInfo], leases : [FIND.LeaseInformation]) {\n\t\tself.profile=profile\n\t\tself.bids=bids\n\t\tself.leases=leases\n\t}\n}\n\n//Check the status of a fin user\npub fun main(user: Address) : FINDReport{\n\n\tlet account=getAccount(user)\n\tlet bidCap = account.getCapability<&FIND.BidCollection{FIND.BidCollectionPublic}>(FIND.BidPublicPath)\n\n\tlet leaseCap = account.getCapability<&FIND.LeaseCollection{FIND.LeaseCollectionPublic}>(FIND.LeasePublicPath)\n\n\treturn FINDReport(\n\t\tprofile: account.getCapability<&{Profile.Public}>(Profile.publicPath).borrow()?.asProfile(),\n\t\tbids: bidCap.borrow()?.getBids() ?? [],\n\t\tleases: leaseCap.borrow()?.getLeaseInformation() ?? []\n\t)\n\n}\n","name_status":"import FIND from 0xFIND\nimport Profile from 0xProfile\n\npub struct FINDNameReport{\n\tpub let profile:Profile.UserProfile?\n\tpub let lease: FIND.LeaseInformation?\n\tpub let address:Address?\n\tpub let status: String\n\tpub let cost: UFix64\n\n\tinit(status: String, profile: Profile.UserProfile?, lease : FIND.LeaseInformation?, address: Address?, cost: UFix64) {\n\t\tself.status=status\n\t\tself.profile=profile\n\t\tself.lease=lease\n\t\tself.address=address\n\t\tself.cost=cost\n\t}\n}\n\n//Check the status of a fin user\npub fun main(name: String) : FINDNameReport{\n\tlet cost=FIND.calculateCost(name)\n\tlet profile= FIND.lookup(name)\n\n\tif let address=profile?.owner?.address {\n\t\tlet account=getAccount(address)\n\t\tlet leaseCap = account.getCapability<&FIND.LeaseCollection{FIND.LeaseCollectionPublic}>(FIND.LeasePublicPath)\n\n\t\tvar lease:FIND.LeaseInformation?=nil\n\n\t\tif leaseCap.check() {\n\t\t\tlease=leaseCap.borrow()!.getLease(name)\n\n\t\t}\n\t  return FINDNameReport(\n\t\t\tstatus: \"taken\",\n\t\t profile: profile?.asProfile(),\n\t\t lease: lease,\n\t\t address:address,\n\t\t cost:  cost\n\t )\n\n\t}\n\n\treturn FINDNameReport(\n\t\tstatus: \"free\",\n\t\tprofile: nil, \n\t\tlease: nil,\n\t\taddress:nil,\n\t\tcost: cost\n\t)\n\n}\n","status":"import FIND from 0xFIND\nimport Profile from 0xProfile\n\n//Check the status of a fin user\npub fun main(name: String) :  &{Profile.Public}? {\n    return FIND.lookup(name)\n}\n"},"vars":{"emulator":{"0xNonFungibleToken":"0xf8d6e0586b0a20c7","0xFUSD":"0xf8d6e0586b0a20c7","0xFungibleToken":"0xee82856bf20e2aa6","0xFlowToken":"0x0ae53cb6e3f42a79","0xFIND":"0xf8d6e0586b0a20c7","0xClock":"0xf8d6e0586b0a20c7","0xProfile":"0xf8d6e0586b0a20c7","0xDebug":"0xf8d6e0586b0a20c7"},"testnet":{"0xNonFungibleToken":"0x631e88ae7f1d7c20","0xFUSD":"0xe223d8a629e49c68","0xFungibleToken":"0x9a0766d93b6608b7","0xFlowToken":"0x7e60df042a9c0868","0xFIND":"0xaa3cefc2514831db","0xClock":"0xaa3cefc2514831db","0xProfile":"0x99ca04281098b33d","0xDebug":"0xaa3cefc2514831db"},"mainnet":{"0xNonFungibleToken":null,"0xFUSD":"0x3c5959b568896393","0xFungibleToken":null,"0xFlowToken":"0x1654653399040a61","0xFIND":null,"0xClock":null,"0xProfile":"0xd796ff17107bbff6","0xDebug":null}}}