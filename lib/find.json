{
   "transactions": {
      "addCuratedCollection": {
         "order": [
            "name",
            "items"
         ],
         "parameters": {
            "items": "[String]",
            "name": "String"
         }
      },
      "bid": {
         "order": [
            "name",
            "amount"
         ],
         "parameters": {
            "amount": "UFix64",
            "name": "String"
         }
      },
      "bidProfile": {
         "order": [
            "name",
            "amount"
         ],
         "parameters": {
            "amount": "UFix64",
            "name": "String"
         }
      },
      "cancelAuction": {
         "order": [
            "name"
         ],
         "parameters": {
            "name": "String"
         }
      },
      "cancelBid": {
         "order": [
            "name"
         ],
         "parameters": {
            "name": "String"
         }
      },
      "createProfile": {
         "order": [
            "name"
         ],
         "parameters": {
            "name": "String"
         }
      },
      "delistSale": {
         "order": [
            "name"
         ],
         "parameters": {
            "name": "String"
         }
      },
      "editProfile": {
         "order": [
            "name",
            "description",
            "avatar",
            "tags",
            "allowStoringFollowers",
            "links"
         ],
         "parameters": {
            "allowStoringFollowers": "Bool",
            "avatar": "String",
            "description": "String",
            "links": "[{String: String}]",
            "name": "String",
            "tags": "[String]"
         }
      },
      "fulfill": {
         "order": [
            "name"
         ],
         "parameters": {
            "name": "String"
         }
      },
      "fulfillAuction": {
         "order": [
            "owner",
            "name"
         ],
         "parameters": {
            "name": "String",
            "owner": "Address"
         }
      },
      "fulfillAuctionBidder": {
         "order": [
            "owner",
            "name"
         ],
         "parameters": {
            "name": "String",
            "owner": "Address"
         }
      },
      "increaseBid": {
         "order": [
            "name",
            "amount"
         ],
         "parameters": {
            "amount": "UFix64",
            "name": "String"
         }
      },
      "listForAuction": {
         "order": [
            "name",
            "auctionStartPrice",
            "auctionReservePrice",
            "auctionDuration",
            "auctionExtensionOnLateBid"
         ],
         "parameters": {
            "auctionDuration": "UFix64",
            "auctionExtensionOnLateBid": "UFix64",
            "auctionReservePrice": "UFix64",
            "auctionStartPrice": "UFix64",
            "name": "String"
         }
      },
      "listForSale": {
         "order": [
            "name",
            "directSellPrice"
         ],
         "parameters": {
            "directSellPrice": "UFix64",
            "name": "String"
         }
      },
      "moveNameToAddress": {
         "order": [
            "name",
            "receiverAddress"
         ],
         "parameters": {
            "name": "String",
            "receiverAddress": "Address"
         }
      },
      "moveNameToName": {
         "order": [
            "name",
            "receiverName"
         ],
         "parameters": {
            "name": "String",
            "receiverName": "String"
         }
      },
      "register": {
         "order": [
            "name",
            "amount"
         ],
         "parameters": {
            "amount": "UFix64",
            "name": "String"
         }
      },
      "registerGift": {
         "order": [
            "name",
            "amount",
            "recipient"
         ],
         "parameters": {
            "amount": "UFix64",
            "name": "String",
            "recipient": "Address"
         }
      },
      "rejectDirectOffer": {
         "order": [
            "name"
         ],
         "parameters": {
            "name": "String"
         }
      },
      "removeCurratedCollection": {
         "order": [
            "name"
         ],
         "parameters": {
            "name": "String"
         }
      },
      "removeRelatedAccount": {
         "order": [
            "name"
         ],
         "parameters": {
            "name": "String"
         }
      },
      "renew": {
         "order": [
            "name",
            "amount"
         ],
         "parameters": {
            "amount": "UFix64",
            "name": "String"
         }
      },
      "sendCharity": {
         "order": [
            "id",
            "recipient"
         ],
         "parameters": {
            "id": "UInt64",
            "recipient": "Address"
         }
      },
      "sendFT": {
         "order": [
            "name",
            "amount",
            "type"
         ],
         "parameters": {
            "amount": "UFix64",
            "name": "String",
            "type": "String"
         }
      },
      "sendFlowWithMessage": {
         "order": [
            "name",
            "amount",
            "message"
         ],
         "parameters": {
            "amount": "UFix64",
            "message": "String",
            "name": "String"
         }
      },
      "sendFlowWithTagAndMessage": {
         "order": [
            "name",
            "amount",
            "message",
            "tag"
         ],
         "parameters": {
            "amount": "UFix64",
            "message": "String",
            "name": "String",
            "tag": "String"
         }
      },
      "sendFusdWithTagAndMessage": {
         "order": [
            "name",
            "amount",
            "message",
            "tag"
         ],
         "parameters": {
            "amount": "UFix64",
            "message": "String",
            "name": "String",
            "tag": "String"
         }
      },
      "sendFusdWithmessage": {
         "order": [
            "name",
            "amount",
            "message"
         ],
         "parameters": {
            "amount": "UFix64",
            "message": "String",
            "name": "String"
         }
      },
      "setMainName": {
         "order": [
            "name"
         ],
         "parameters": {
            "name": "String"
         }
      },
      "setPrivateMode": {
         "order": [
            "mode"
         ],
         "parameters": {
            "mode": "Bool"
         }
      },
      "setProfile": {
         "order": [
            "avatar"
         ],
         "parameters": {
            "avatar": "String"
         }
      },
      "setRelatedAccount": {
         "order": [
            "name",
            "address"
         ],
         "parameters": {
            "address": "Address",
            "name": "String"
         }
      },
      "startAuction": {
         "order": [
            "name"
         ],
         "parameters": {
            "name": "String"
         }
      },
      "storeCuratedCollections": {
         "order": [
            "collections"
         ],
         "parameters": {
            "collections": "{String: [String]}"
         }
      }
   },
   "scripts": {
      "address_status": {
         "order": [
            "user"
         ],
         "parameters": {
            "user": "Address"
         }
      },
      "collections": {
         "order": [
            "address"
         ],
         "parameters": {
            "address": "Address"
         }
      },
      "curatedCollections": {
         "order": [
            "address"
         ],
         "parameters": {
            "address": "Address"
         }
      },
      "flobits": {
         "order": [
            "addr"
         ],
         "parameters": {
            "addr": "Address"
         }
      },
      "gg": {
         "order": [
            "addr"
         ],
         "parameters": {
            "addr": "Address"
         }
      },
      "hasCharity": {
         "order": [
            "user"
         ],
         "parameters": {
            "user": "Address"
         }
      },
      "isFindUser": {
         "order": [
            "user"
         ],
         "parameters": {
            "user": "Address"
         }
      },
      "matrixworld": {
         "order": [
            "address"
         ],
         "parameters": {
            "address": "Address"
         }
      },
      "name": {
         "order": [
            "address"
         ],
         "parameters": {
            "address": "Address"
         }
      },
      "nameCrawler": {
         "order": [
            "names"
         ],
         "parameters": {
            "names": "[String]"
         }
      },
      "name_status": {
         "order": [
            "name"
         ],
         "parameters": {
            "name": "String"
         }
      },
      "names": {
         "order": [
            "address"
         ],
         "parameters": {
            "address": "[Address]"
         }
      },
      "profile": {
         "order": [
            "address"
         ],
         "parameters": {
            "address": "Address"
         }
      },
      "remaining": {
         "order": [
            "user"
         ],
         "parameters": {
            "user": "Address"
         }
      },
      "reserveStatus": {
         "order": [
            "user"
         ],
         "parameters": {
            "user": "Address"
         }
      },
      "starly": {
         "order": [
            "address"
         ],
         "parameters": {
            "address": "Address"
         }
      },
      "status": {
         "order": [
            "name"
         ],
         "parameters": {
            "name": "String"
         }
      }
   },
   "networks": {
      "emulator": {
         "scripts": {
            "address_status": "import FIND from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport RelatedAccounts from 0xf8d6e0586b0a20c7\n\npub struct FINDReport{\n\tpub let profile:Profile.UserProfile?\n\tpub let bids: [FIND.BidInfo]\n\tpub let relatedAccounts: { String: Address}\n\tpub let leases: [FIND.LeaseInformation]\n\tpub let privateMode: Bool\n\n\tinit(profile: Profile.UserProfile?, relatedAccounts: {String: Address}, bids: [FIND.BidInfo], leases : [FIND.LeaseInformation], privateMode: Bool) {\n\t\tself.profile=profile\n\t\tself.bids=bids\n\t\tself.leases=leases\n\t\tself.relatedAccounts=relatedAccounts\n\t\tself.privateMode=privateMode\n\t}\n}\n\n//Check the status of a fin user\npub fun main(user: Address) : FINDReport{\n\n\tlet account=getAccount(user)\n\tlet bidCap = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\n\tlet leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\tlet profile=account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath).borrow()\n\treturn FINDReport(\n\t\tprofile: profile?.asProfile(),\n\t\trelatedAccounts: RelatedAccounts.findRelatedFlowAccounts(address:user),\n\t\tbids: bidCap.borrow()?.getBids() ?? [],\n\t\tleases: leaseCap.borrow()?.getLeaseInformation() ?? [],\n\t\tprivateMode: profile?.isPrivateModeEnabled() ?? false\n\t)\n\n}",
            "collections": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport CharityNFT from 0xf8d6e0586b0a20c7\n\n//mainnet\nimport Art from 0xd796ff17107bbff6\nimport Marketplace from 0xd796ff17107bbff6\nimport GooberXContract from 0x34f2bf4a80bb0f69\nimport Flovatar from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\nimport RareRooms_NFT from 0x329feb3ab062d289\nimport CNN_NFT from 0x329feb3ab062d289\nimport Canes_Vault_NFT from 0x329feb3ab062d289\nimport DGD_NFT from 0x329feb3ab062d289\nimport RaceDay_NFT from 0x329feb3ab062d289\nimport The_Next_Cartel_NFT from 0x329feb3ab062d289\nimport UFC_NFT from 0x329feb3ab062d289\nimport MotoGPCard from 0xa49cc0ee46c54bfb\nimport Gaia from 0x8b148183c28ff88f\nimport ChainmonstersRewards from 0x93615d25d14fa337\nimport Moments from 0xd4ad4740ee426334\nimport MatrixWorldFlowFestNFT from 0x2d2750f240198f91\nimport SturdyItems from 0x427ceada271aa0b1\nimport Evolution from 0xf4264ac8f3256818\nimport GeniaceNFT from 0xabda6627c70c7f52\nimport OneFootballCollectible from 0x6831760534292098\nimport CryptoPiggo from 0xd3df824bf81910a4\nimport GoatedGoatsVouchers from 0xdfc74d9d561374c0\nimport TraitPacksVouchers from 0xdfc74d9d561374c0\nimport HaikuNFT from 0xf61e40c19db2a9e2\nimport KlktnNFT from 0xabd6e80be7e9682c\nimport Mynft from 0xf6fcbef550d97aa5\n\n//xtingles\nimport Collectible from 0xf5b0eb433389ac3f\n\n\npub struct MetadataCollections {\n\n\tpub let items: {String : MetadataCollectionItem}\n\tpub let collections: {String : [String]}\n\tpub let curatedCollections: {String : [String]}\n\n\tinit(items: {String : MetadataCollectionItem}, collections: {String : [String]}, curatedCollections: {String: [String]}) {\n\t\tself.items=items\n\t\tself.collections=collections\n\t\tself.curatedCollections=curatedCollections\n\t}\n}\n\n\npub struct MetadataCollection{\n\tpub let type: String\n\tpub let items: [MetadataCollectionItem]\n\n\tinit(type:String, items: [MetadataCollectionItem]) {\n\t\tself.type=type\n\t\tself.items=items\n\t}\n}\n\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let listPrice: UFix64?\n\tpub let listToken: String?\n\tpub let contentType:String\n\tpub let rarity:String\n\n\n\tinit(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n\t\tself.id=id\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.listToken=listToken\n\t\tself.listPrice=listPrice\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\npub fun main(address: Address) : MetadataCollections? {\n\n\tlet resultMap : {String : MetadataCollectionItem} = {}\n\tlet account = getAccount(address)\n\tlet results : {String :  [String]}={}\n\n\tlet flovatarList= Flovatar.getFlovatars(address: address)\n\tlet flovatarMarketDetails = FlovatarMarketplace.getFlovatarSales(address: address)\n\tif flovatarList.length \u003e 0 || flovatarMarketDetails.length \u003e 0 {\n\t\tlet items: [String] = []\n\t\tfor flovatar in flovatarList  {\n\t\t\tvar name = flovatar.name\n\t\t\tif name == \"\" {\n\t\t\t\tname=\"Flovatar #\".concat(flovatar.id.toString())\n\t\t\t}\n\n\t\t\tvar rarity=\"common\"\n\t\t\tif flovatar.metadata.legendaryCount \u003e 0 {\n\t\t\t\trarity=\"legendary\"\n\t\t\t}else if flovatar.metadata.epicCount \u003e 0 {\n\t\t\t\trarity=\"epic\"\n\t\t\t}else if flovatar.metadata.rareCount \u003e 0 {\n\t\t\t\trarity=\"rare\"\n\t\t\t}\n\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: flovatar.id, \n\t\t\t\tname: name, \n\t\t\t\timage: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n\t\t\t\turl: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: rarity\n\t\t\t)\n\t\t\tlet itemId=\"Flovatar\".concat(flovatar.id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tfor flovatar in flovatarMarketDetails  {\n\t\t\tvar\tname=\"Flovatar #\".concat(flovatar.id.toString())\n\n\t\t\tvar rarity=\"common\"\n\t\t\tif flovatar.metadata.legendaryCount \u003e 0 {\n\t\t\t\trarity=\"legendary\"\n\t\t\t}else if flovatar.metadata.epicCount \u003e 0 {\n\t\t\t\trarity=\"epic\"\n\t\t\t}else if flovatar.metadata.rareCount \u003e 0 {\n\t\t\t\trarity=\"rare\"\n\t\t\t}\n\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: flovatar.id, \n\t\t\t\tname: name, \n\t\t\t\timage: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n\t\t\t\turl: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n\t\t\t\tlistPrice: flovatar.price,\n\t\t\t\tlistToken: \"Flow\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: rarity\n\t\t\t)\n\n\t\t\tlet itemId=\"Flovatar\".concat(flovatar.id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Flovatar\"] = items\n\t\t}\n\t}\n\n\tlet versusMarketplace = account.getCapability\u003c\u0026{Marketplace.SalePublic}\u003e(Marketplace.CollectionPublicPath)\n\tlet versusImageUrlPrefix = \"https://res.cloudinary.com/dxra4agvf/image/upload/c_fill,w_600/f_auto/maincache\"\n\tlet artList = Art.getArt(address: address)\n\tif artList.length \u003e 0 || versusMarketplace.check() {\n\t\tlet items: [String] = []\n\t\tfor art in artList {\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: art.id, \n\t\t\t\tname: art.metadata.name.concat(\" edition \").concat(art.metadata.edition.toString()).concat(\"/\").concat(art.metadata.maxEdition.toString()).concat(\" by \").concat(art.metadata.artist),  \n\t\t\t\timage: versusImageUrlPrefix.concat(art.cacheKey), \n\t\t\t\turl: \"https://www.versus.auction/piece/\".concat(address.toString()).concat(\"/\").concat(art.id.toString()).concat(\"/\"),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"Versus\".concat(art.id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\t\t}\n\t\tif versusMarketplace.check() {\n\t\t\tlet versusMarket = versusMarketplace.borrow()!.listSaleItems()\n\t\t\tfor saleItem in versusMarket {\n\t\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\t\tid: saleItem.id, \n\t\t\t\t\tname: saleItem.art.name.concat(\" edition \").concat(saleItem.art.edition.toString()).concat(\"/\").concat(saleItem.art.maxEdition.toString()).concat(\" by \").concat(saleItem.art.artist),\n\t\t\t\t\timage: versusImageUrlPrefix.concat(saleItem.cacheKey), \n\t\t\t\t\turl: \"https://www.versus.auction/listing/\".concat(saleItem.id.toString()).concat(\"/\"),\n\t\t\t\t\tlistPrice: saleItem.price,\n\t\t\t\t\tlistToken: \"Flow\",\n\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\trarity: \"\"\n\t\t\t\t)\n\n\t\t\t\tlet itemId=\"Versus\".concat(saleItem.id.toString())\n\t\t\t\titems.append(itemId)\n\t\t\t\tresultMap[itemId] = item\n\t\t\t}\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"Versus\"]= items\n\t\t}\n\t}\n\n\n\n\n\tlet goobersCap = account.getCapability\u003c\u0026GooberXContract.Collection{NonFungibleToken.CollectionPublic, GooberXContract.GooberCollectionPublic}\u003e(GooberXContract.CollectionPublicPath)\n\tif goobersCap.check() {\n\t\tlet items: [String] = []\n\t\tlet goobers = goobersCap.borrow()!.listUsersGoobers()\n\t\tfor id in goobers.keys {\n\t\t\tlet goober = goobers[id]!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"Goober #\".concat(id.toString()),\n\t\t\t\timage: goober.uri,\n\t\t\t\turl: \"https://partymansion.io/gooberz/\".concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"Gooberz\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"Gooberz\"] = items\n\t\t}\n\t}\n\n\tlet rareRoomCap = account.getCapability\u003c\u0026RareRooms_NFT.Collection{RareRooms_NFT.RareRooms_NFTCollectionPublic}\u003e(RareRooms_NFT.CollectionPublicPath)\n\tif rareRoomCap.check() {\n\t\tlet collection = rareRoomCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowRareRooms_NFT(id: id)!\n\t\t\tlet metadata = RareRooms_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://rarerooms.io/tokens/\".concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"RareRooms\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"RareRooms\"] = items\n\t\t}\n\t}\n\n\tlet cnnCap = account.getCapability\u003c\u0026CNN_NFT.Collection{CNN_NFT.CNN_NFTCollectionPublic}\u003e(CNN_NFT.CollectionPublicPath)\n\tif cnnCap.check() {\n\t\tlet collection = cnnCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowCNN_NFT(id: id)!\n\t\t\tlet metadata = CNN_NFT.getSetMetadata(setId: nft.setId)!\n\n\t\t  var image= metadata[\"preview\"]!\n\t\t\tvar contentType=\"image\"\n\t\t\t/*\n\t\t\tif metadata[\"image_file_type\"]! == \"mp4\" {\n\t\t\t\timage=metadata[\"image\"]!\n\t\t\t\tcontentType=\"video\"\n\t\t\t}\n\t\t\t*/\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: image,\n\t\t\t\turl: \"http://vault.cnn.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"CNN\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"CNN\"] = items\n\t\t}\n\t}\n\n\tlet canesVaultCap = account.getCapability\u003c\u0026Canes_Vault_NFT.Collection{Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic}\u003e(Canes_Vault_NFT.CollectionPublicPath)\n\tif canesVaultCap.check() {\n\t\tlet collection = canesVaultCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowCanes_Vault_NFT(id: id)!\n\t\t\tlet metadata = Canes_Vault_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tvar image= metadata[\"preview\"]!\n\t\t\tvar contentType=\"image\"\n\t\t\t/*\n\t\t\tif metadata[\"image_file_type\"]! == \"mp4\" {\n\t\t\t\timage=metadata[\"image\"]!\n\t\t\t\tcontentType=\"video\"\n\t\t\t}\n\t\t\t*/\n\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: image,\n\t\t\t\turl: \"https://canesvault.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"Canes_Vault_NFT\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Canes_Vault_NFT\"] = items\n\t\t}\n\t}\n\n\tlet dgdCap = account.getCapability\u003c\u0026DGD_NFT.Collection{DGD_NFT.DGD_NFTCollectionPublic}\u003e(DGD_NFT.CollectionPublicPath)\n\tif dgdCap.check() {\n\t\tlet collection = dgdCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowDGD_NFT(id: id)!\n\t\t\tlet metadata = DGD_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tvar image= metadata[\"preview\"]!\n\t\t\tvar contentType=\"image\"\n\t\t\t/*\n\t\t\tif metadata[\"image_file_type\"]! == \"mp4\" {\n\t\t\t\timage=metadata[\"image\"]!\n\t\t\t\tcontentType=\"video\"\n\t\t\t}\n\t\t\t*/\n\n\t\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: image,\n\t\t\t\turl: \"https://www.theplayerslounge.io/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"DGD_NFT\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"DGD_NFT\"] = items\n\t\t}\n\t}\n\n\tlet raceDayCap = account.getCapability\u003c\u0026RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic}\u003e(RaceDay_NFT.CollectionPublicPath)\n\tif raceDayCap.check() {\n\t\tlet collection = raceDayCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowRaceDay_NFT(id: id)!\n\t\t\tlet metadata = RaceDay_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tvar image= metadata[\"preview\"]!\n\t\t\tvar contentType=\"image\"\n\t\t\t/*\n\t\t\tif metadata[\"image_file_type\"]! == \"mp4\" {\n\t\t\t\timage=metadata[\"image\"]!\n\t\t\t\tcontentType=\"video\"\n\t\t\t}\n\t\t\t*/\n\n\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: image, \n\t\t\t\turl: \"https://www.racedaynft.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"RaceDay_NFT\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"RaceDay_NFT\"] = items\n\t\t}\n\t}\n\n\tlet nextCartelCap = account.getCapability\u003c\u0026The_Next_Cartel_NFT.Collection{The_Next_Cartel_NFT.The_Next_Cartel_NFTCollectionPublic}\u003e(The_Next_Cartel_NFT.CollectionPublicPath)\n\tif nextCartelCap.check() {\n\t\tlet collection = nextCartelCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowThe_Next_Cartel_NFT(id: id)!\n\t\t\tlet metadata = The_Next_Cartel_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tvar image= metadata[\"preview\"]!\n\t\t\tvar contentType=\"image\"\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\t// we use \"preview\" and not \"image\" because of potential .glg and .mp4 file types\n\t\t\t\timage: image,\n\t\t\t\turl: \"https://thenextcartel.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"The_Next_Cartel_NFT\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"The_Next_Cartel_NFT\"] = items\n\t\t}\n\t}\n\n\tlet ufcCap = account.getCapability\u003c\u0026UFC_NFT.Collection{UFC_NFT.UFC_NFTCollectionPublic}\u003e(UFC_NFT.CollectionPublicPath)\n\tif ufcCap.check() {\n\t\tlet collection = ufcCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowUFC_NFT(id: id)!\n\t\t\tlet metadata = UFC_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tvar image= metadata[\"image\"]!\n\t\t\tvar contentType=\"video\"\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: image,\n\t\t\t\turl: \"https://www.ufcstrike.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"UFC\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"UFC\"] = items\n\t\t}\n\t}\n\n\tlet motoGPCollection = account.getCapability\u003c\u0026MotoGPCard.Collection{MotoGPCard.ICardCollectionPublic}\u003e(/public/motogpCardCollection)\n\tif motoGPCollection.check() {\n\t\tlet motoGPNfts = motoGPCollection.borrow()!.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in motoGPNfts {\n\t\t\tlet nft = motoGPCollection.borrow()!.borrowCard(id: id)!\n\t\t\tlet metadata = nft.getCardMetadata()!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: metadata.imageUrl,\n\t\t\t\turl: \"https://motogp-ignition.com/nft/card/\".concat(id.toString()).concat(\"?owner=\").concat(address.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\n\t\t\tlet itemId=\"MotoGP\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"MotoGP\"] = items\n\t\t}\n\t}\n\n\tlet gaiaCollection = account.getCapability\u003c\u0026{Gaia.CollectionPublic}\u003e(Gaia.CollectionPublicPath)\n\tif gaiaCollection.check() {\n\n\t\tlet gaiaNfts = gaiaCollection.borrow()!.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in gaiaNfts {\n\t\t\tlet nft = gaiaCollection.borrow()!.borrowGaiaNFT(id: id)!\n\t\t\tlet metadata = Gaia.getTemplateMetaData(templateID: nft.data.templateID)!\n\n\n\t\t\t//For ballerz we can do this...\n\t\t\tvar url=\"http://ongaia.com/ballerz/\".concat(metadata[\"id\"]!)\n\t\t\tvar name=metadata[\"title\"]!\n\n\t\t\tif let seriesFullName=metadata[\"series\"] {\n\n\t\t\t\tif seriesFullName==\"Shareef O\\u{2019}Neal - Basketball\" {\n\t\t\t\t\t//If the series is basketball with shareef we can do this\n\t\t\t\t\turl=\"http://ongaia.com/sharef/\".concat(id.toString())\n\t\t\t\t\tname=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n\t\t\t\t}else if seriesFullName==\"Bryson DeChambeau - Vegas, Baby!\" {\n\t\t\t\t\t//For golf there is yet another way\n\t\t\t\t\turl=\"http://ongaia.com/bryson/\".concat(nft.data.mintNumber.toString())\n\t\t\t\t\tname=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tlet item= MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: name,\n\t\t\t\timage: metadata[\"img\"]!,\n\t\t\t\turl: url,\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"Gaia\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Gaia\"] = items\n\t\t}\n\t}\n\n\t/*\n\tlet chamonsterSeasonTable :  {UInt32: String} = {0 : \"kickstarter\", 1 : \"alpha\", 2 : \"genesis\", 4 : \"flowfest2021\" , 3: \"closedbeta\" }\n\n\tlet chainmonstersRewardsCollection = account.getCapability\u003c\u0026{ChainmonstersRewards.ChainmonstersRewardCollectionPublic}\u003e(/public/ChainmonstersRewardCollection)\n\tif chainmonstersRewardsCollection.check() {\n\t\tlet nfts = chainmonstersRewardsCollection.borrow()!.getIDs()\n\t\tlet items: [MetadataCollectionItem] = []\n\t\tfor id in nfts {\n\t\t\tlet nft = chainmonstersRewardsCollection.borrow()!.borrowReward(id: id)!\n\t\t\tlet rewardID = nft.data.rewardID\n\t\t\t// Other interesting metadata available are:\n\t\t\t// \t\t- serialNumber: nft.data.serialNumber\n\t\t\t// \t\t- totalMinted: ChainmonstersRewards.getNumRewardsMinted(rewardID: nft.data.rewardID)!\n\t\t\tlet season = ChainmonstersRewards.getRewardSeason(rewardID:nft.data.rewardID)!\n\n\t\t\tvar seasonName = chamonsterSeasonTable[season] ?? \"unknown\".concat(season.toString())\n\n\t\t\tif season == 3 \u0026\u0026 rewardID \u003c 45 {\n\t\t\t\tseasonName = \"flowfest2021\"\n\t\t\t}\n\t\t\titems.append(MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: ChainmonstersRewards.getRewardMetaData(rewardID: nft.data.rewardID)!,\n\t\t\t\timage: \"https://chainmonsters.com/images/rewards/\".concat(seasonName).concat(\"/\").concat(rewardID.toString()).concat(\".png\"),\n\t\t\t\turl: \"https://chainmonsters.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\"\n\t\t\t))\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"ChainmonstersRewards\"] = MetadataCollection(type: Type\u003c@ChainmonstersRewards.Collection\u003e().identifier, items: items)\n\t\t}\n\t}\n\t*/\n\n\tlet jambbCap = account.getCapability\u003c\u0026Moments.Collection{Moments.CollectionPublic}\u003e(Moments.CollectionPublicPath)\n\tif jambbCap.check() {\n\t\tlet nfts = jambbCap.borrow()!.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in nfts {\n\t\t\tlet nft = jambbCap.borrow()!.borrowMoment(id: id)!\n\t\t\tlet metadata=nft.getMetadata()\n\t\t\tlet item  =MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.contentName,\n\t\t\t\timage: \"ipfs://\".concat(metadata.videoHash),\n\t\t\t\turl: \"http://jambb.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"Jambb\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Jambb\"] = items\n\t\t}\n\t}\n\n\tlet mw = MatrixWorldFlowFestNFT.getNft(address:address)\n\tif mw.length \u003e 0 {\n\t\tlet items: [String] = []\n\t\tfor nft in mw {\n\t\t\tlet metadata=nft.metadata\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: nft.id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: metadata.animationUrl,\n\t\t\t\turl: \"https://matrixworld.org/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"MatrixWorldFlowFest\".concat(nft.id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"MatrixWorld\"] = items\n\t\t}\n\t}\n\n\tlet sturdyCollectionCap = account\n\t.getCapability\u003c\u0026SturdyItems.Collection{SturdyItems.SturdyItemsCollectionPublic}\u003e(SturdyItems.CollectionPublicPath)\n\tif sturdyCollectionCap.check() {\n\t\tlet sturdyNfts = sturdyCollectionCap.borrow()!.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in sturdyNfts {\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = sturdyCollectionCap.borrow()!.borrowSturdyItem(id: id)!\n\t\t\t// the only thing we can play with is the nft title which is for example:\n\t\t\t// \t- \"HOODLUM#10\"\n\t\t\t// \t- \"HOLIDAY MYSTERY BADGE 2021\"\n\t\t\t//  - \"EXCALIBUR\"\n\t\t\tlet isHoodlum = nft.tokenTitle.slice(from: 0, upTo: 7) == \"HOODLUM\"\n\t\t\tif isHoodlum {\n\t\t\t\t// the hoodlum id is needed to retrieve the image but is not in the nft\n\t\t\t\tlet hoodlumId = nft.tokenTitle.slice(from: 8, upTo: nft.tokenTitle.length)\n\t\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tname: nft.tokenTitle,\n\t\t\t\t\timage: \"https://hoodlumsnft.com/_next/image?url=%2Fthumbs%2FsomeHoodlum_\".concat(hoodlumId).concat(\".png\u0026w=1920\u0026q=75\"),\n\t\t\t\t\turl: \"https://hoodlumsnft.com/\",\n\t\t\t\t\tlistPrice:nil,\n\t\t\t\t\tlistToken:nil,\n\t\t\t\t\tcontentType:\"image\",\n\t\t\t\t\trarity: \"\"\n\t\t\t\t)\n\t\t\t\tlet itemId=\"Hoodlums\".concat(id.toString())\n\t\t\t\titems.append(itemId)\n\t\t\t\tresultMap[itemId] = item\n\t\t\t}\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"Hoodlums\"] = items\n\t\t}\n\t}\n\n\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\tif charityCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = charityCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowCharity(id: id)!\n\t\t\tlet metadata = nft.getMetadata()\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: metadata[\"thumbnail\"]!,\n\t\t\t\turl: metadata[\"originUrl\"]!,\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType:\"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"Charity\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"Find\"] = items\n\t\t}\n\t}\n\n\tlet evolutionCap=account.getCapability\u003c\u0026{Evolution.EvolutionCollectionPublic}\u003e(/public/f4264ac8f3256818_Evolution_Collection)\n\tif evolutionCap.check() {\n\t\tlet evolution=evolutionCap.borrow()!\n\t\tlet nfts = evolution.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in nfts{\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = evolution.borrowCollectible(id: id)!\n\t\t\tlet metadata = Evolution.getItemMetadata(itemId: nft.data.itemId)!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"Title\"]!.concat(\" #\").concat(nft.data.serialNumber.toString()),\n\t\t\t\timage: \"https://storage.viv3.com/0xf4264ac8f3256818/mv/\".concat(nft.data.itemId.toString()),\n\t\t\t\turl: \"https://www.evolution-collect.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType:\"video\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"Evolution\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Evolution\"] = items\n\t\t}\n\t}\n\n\n\tlet geniaceCap = account.getCapability\u003c\u0026GeniaceNFT.Collection{NonFungibleToken.CollectionPublic, GeniaceNFT.GeniaceNFTCollectionPublic}\u003e(GeniaceNFT.CollectionPublicPath)\n\tif geniaceCap.check() {\n\t\tlet geniace=geniaceCap.borrow()!\n\t\tlet nfts = geniace.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in nfts{\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = geniace.borrowGeniaceNFT(id: id)!\n\t\t\tlet metadata = nft.metadata\n\t\t\tvar rarity=\"\"\n\t\t\tif metadata.rarity == GeniaceNFT.Rarity.Collectible {\n\t\t\t\trarity=\"Collectible\"\n\t\t\t}else if metadata.rarity == GeniaceNFT.Rarity.Rare {\n\t\t\t\trarity=\"Rare\"\n\t\t\t}else if metadata.rarity == GeniaceNFT.Rarity.UltraRare {\n\t\t\t\trarity=\"UltraRare\"\n\t\t\t}\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: metadata.imageUrl,\n\t\t\t\turl: \"https://www.geniace.com/product/\".concat(metadata.name),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: metadata.data[\"mimetype\"]!,\n\t\t\t\trarity: rarity,\n\t\t\t)\n\n\t\t\tlet itemId=\"Geniace\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Geniace\"] = items\n\t\t}\n\t}\n\n\t// https://flow-view-source.com/mainnet/account/0x6831760534292098/contract/OneFootballCollectible\n\tlet oneFootballCollectibleCap = account.getCapability\u003c\u0026OneFootballCollectible.Collection{OneFootballCollectible.OneFootballCollectibleCollectionPublic}\u003e(OneFootballCollectible.CollectionPublicPath)\n\tif oneFootballCollectibleCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = oneFootballCollectibleCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowOneFootballCollectible(id: id)!\n\t\t\tlet metadata = nft.getTemplate()!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: \"ipfs://\".concat(metadata.media),\n\t\t\t\turl: \"https://xmas.onefootball.com/\".concat(account.address.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\tlet itemId=\"OneFootballCollectible\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"OneFootballCollectible\"] = items\n\t\t}\n\t}\n\n\n\tlet cryptoPiggoCap = account.getCapability\u003c\u0026{CryptoPiggo.CryptoPiggoCollectionPublic}\u003e(CryptoPiggo.CollectionPublicPath)\n\tif cryptoPiggoCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = cryptoPiggoCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowItem(id: id)!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"CryptoPiggo #\".concat(id.toString()),\n\t\t\t\timage: \"https://s3.us-west-2.amazonaws.com/crypto-piggo.nft/piggo-\".concat(id.toString()).concat(\".png\"),\n\t\t\t\turl: \"https://rareworx.com/piggo/details/\".concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\tlet itemId=\"CryptoPiggo\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"CryptoPiggo\"] = items\n\t\t}\n\t}\n\n\tlet xtingles = Collectible.getCollectibleDatas(address:address) \n\tif xtingles.length \u003e 0 {\n\t\tlet items: [String] = []\n\t\tfor nft in xtingles {\n\n\t\t\tvar image=nft.metadata.link\n\n\t\t\tlet prefix=\"https://\"\n\t\t\tif image.slice(from:0, upTo:prefix.length) != prefix {\n\t\t\t\timage=\"ipfs://\".concat(image)\n\t\t\t}\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: nft.id,\n\t\t\t\tname: nft.metadata.name.concat(\" #\").concat(nft.metadata.edition.toString()),\n\t\t\t\timage: image,\n\t\t\t\turl: \"http://xtingles.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"Xtingles\".concat(nft.id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"Xtingles\"] = items\n\t\t}\n\t}\n\n\tlet goatsCap = account.getCapability\u003c\u0026{GoatedGoatsVouchers.GoatsVoucherCollectionPublic}\u003e(GoatedGoatsVouchers.CollectionPublicPath)\n\tvar goats : [String]=[]\n\tif goatsCap.check() {\n\t\tlet goatsImageUrl= GoatedGoatsVouchers.getCollectionMetadata()[\"mediaURL\"]!\n\t\tlet collection = goatsCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"Goated Goat Base Goat Voucher #\".concat(id.toString()),\n\t\t\t\timage: goatsImageUrl, \n\t\t\t\turl: \"https://goatedgoats.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\tlet itemId=\"GoatedGoatsVoucher\".concat(id.toString())\n\t\t\tgoats.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\n\n\tlet goatsTraitCap = account.getCapability\u003c\u0026{TraitPacksVouchers.PackVoucherCollectionPublic}\u003e(TraitPacksVouchers.CollectionPublicPath)\n\tif goatsTraitCap.check() {\n\t\tlet goatsImageUrl= TraitPacksVouchers.getCollectionMetadata()[\"mediaURL\"]!\n\t\tlet collection = goatsTraitCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"Goated Goat Trait Pack Voucher #\".concat(id.toString()),\n\t\t\t\timage: goatsImageUrl, \n\t\t\t\turl: \"https://goatedgoats.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\tlet itemId=\"GoatedGoatsTraitVoucher\".concat(id.toString())\n\t\t\tgoats.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\n\tif goats.length != 0 {\n\t\t\tresults[\"GoatedGoats\"] = goats\n\t}\n\n  let bitkuCap = account.getCapability\u003c\u0026{HaikuNFT.HaikuCollectionPublic}\u003e(HaikuNFT.HaikuCollectionPublicPath)\n\tif bitkuCap.check() {\n\t\tlet collection = bitkuCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowHaiku(id: id)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"Bitku #\".concat(id.toString()),\n\t\t\t\timage: nft.text,\n\t\t\t\turl: \"https://bitku.art/#\".concat(address.toString()).concat(\"/\").concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"text\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"BitKu\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"BitKu\"] = items\n\t\t}\n\t}\n\tlet klktnCap = account.getCapability\u003c\u0026{KlktnNFT.KlktnNFTCollectionPublic}\u003e(KlktnNFT.CollectionPublicPath)\n\tif klktnCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = klktnCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowKlktnNFT(id: id)!\n\n\t\t\tlet metadata=nft.getNFTMetadata()\n\t\t\t/*\n\n\t\t\tResult: {\"uri\": \"ipfs://bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym\", \"name\": \"Kevin Woo - What is KLKTN?\", \"mimeType\": \"video/mp4\", \"media\": \"https://ipfs.io/ipfs/bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym/fb91ad34d61dde04f02ad240f0ca924902d8b4a3da25daaf0bb1ed769977848c.mp4\", \"description\": \"K-pop sensation Kevin Woo has partnered up with KLKTN to enhance his artist to fan interactions and experiences within his fandom. Join our chat to learn more: https://discord.gg/UJxb4erfUw\"}\n\n\t\t\t*/\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: metadata[\"media\"]!,\n\t\t\t\turl: \"https://klktn.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"video\", //metadata[\"mimeType\"]!,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t    let itemId=\"KLKTN\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"KLKTN\"] = items\n\t\t}\n\t}\n\n\tlet mynftCap = account.getCapability\u003c\u0026{Mynft.MynftCollectionPublic}\u003e(Mynft.CollectionPublicPath)\n\tif mynftCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = mynftCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowArt(id: id)!\n\t\t\tlet metadata=nft.metadata\n\n\t\t\tvar image= metadata.ipfsLink\n\t\t\tif image == \"\" {\n\t\t\t\timage=\"https://arweave.net/\".concat(metadata.arLink)\n\t\t\t}\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: image,\n\t\t\t\turl: \"http://mynft.io\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n      let itemId=\"mynft\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"mynft\"] = items\n\t\t}\n\t}\n\n\tif results.keys.length == 0 {\n\t\treturn nil\n\t}\n\n\tlet publicPath=/public/FindCuratedCollections\n\tlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n\tvar curatedCollections : {String: [String]} = {}\n\tif link.check() {\n\t\tlet curated = link.borrow()!\n\t\tfor curatedKey in curated.keys {\n\t\t\tcuratedCollections[curatedKey] = curated[curatedKey]!\n\t\t}\n\t}\n\n\treturn MetadataCollections(items: resultMap, collections:results, curatedCollections: curatedCollections)\n}",
            "curatedCollections": "pub fun main(address: Address) : \u0026{String: [String]}? {\n\tlet account=getAccount(address)\n\tlet publicPath=/public/FindCuratedCollections\n\tlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n\tif link.check() {\n\t\treturn link.borrow()\n\t}\n\treturn nil\n}",
            "flobits": "import FlovatarComponent from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let listPrice: UFix64?\n\tpub let listToken: String?\n\tpub let contentType:String\n\tpub let rarity:String\n\n\n\tinit(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n\t\tself.id=id\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.listToken=listToken\n\t\tself.listPrice=listPrice\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\npub fun main(addr: Address) : [MetadataCollectionItem] {\n\n\tlet flovatarComponents= FlovatarComponent.getComponents(address: addr)\n\n\tlet templateNumbers : {UInt64: UInt64} = {}\n\tlet templateData : {UInt64: FlovatarComponent.ComponentData} = {}\n\tfor flovatar in flovatarComponents {\n\n\t\tlet templateId= flovatar.templateId\n\t\tvar number:UInt64=1\n\t\tif templateNumbers[templateId] == nil {\n\t\t\ttemplateNumbers[templateId] = (1 as UInt64)\n\t\t\ttemplateData[templateId]=flovatar\n\t\t} else {\n\t\t\ttemplateNumbers[templateId] = templateNumbers[templateId]! + 1\n\t\t}\n\t}\n\n\n\tlet flovatarMarketComponents=FlovatarMarketplace.getFlovatarComponentSales(address:addr)\n\n\tfor flovatar in flovatarMarketComponents {\n\n\t\tlet templateId= flovatar.metadata.templateId\n\t\t\tvar number:UInt64=1\n\t\t\tif templateNumbers[templateId] == nil {\n\t\t\t\ttemplateNumbers[templateId] = (1 as UInt64)\n\t\t\t\ttemplateData[templateId]=FlovatarComponent.getComponent(address:addr, componentId: flovatar.id)!\n\t\t\t} else {\n\t\t\t\ttemplateNumbers[templateId] = templateNumbers[templateId]! + 1\n\t\t\t}\n\t}\n\n\n\tlet flovatarC : [MetadataCollectionItem] = []\n\tfor templateId in templateData.keys {\n\t\tlet template=templateData[templateId]!\n\n\n\t\tvar name=template.name\n\n\t\tif templateId == 75 || templateId==74 || templateId == 73 {\n\t\t\tname=name.concat(\" Booster\")\n\t\t}\n\n\t\tif templateNumbers[templateId]! \u003e 1 {\n\t\t\tname=name.concat(\" x \").concat(templateNumbers[templateId]!.toString())\n\t\t} \n\n\t\tlet item=MetadataCollectionItem(\n\t\t\tid: template.id, \n\t\t\tname: name, \n\t\t\timage: \"https://flovatar.com/api/image/template/\".concat(templateId.toString()),\n\t\t\turl: \"https://flovatar.com\",\n\t\t\tlistPrice: nil,\n\t\t\tlistToken: nil,\n\t\t\tcontentType: \"image\",\n\t\t\trarity: template.rarity\n\t\t)\n\n\t\tflovatarC.append(item)\n\t}\n\n\treturn flovatarC\n\n}",
            "gg": "import GoatedGoatsVouchers from 0xdfc74d9d561374c0\n\npub fun main(addr: Address) : {String:String} {\n\n\tlet account=getAccount(addr)\n\n\tlet goatedGoatsCap = account.getCapability\u003c\u0026{GoatedGoatsVouchers.GoatsVoucherCollectionPublic}\u003e(GoatedGoatsVouchers.CollectionPublicPath)\n\tif goatedGoatsCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection=goatedGoatsCap.borrow()!\n\t\tlet goats = collection.getIDs()\n\t\tfor id in goats {\n\n\t\t\tlet i = collection.borrowVoucher(id:id)!\n\t\t\tlet m = i.getMetadata()\n\t\t\tm[\"id\"] = id.toString()\n\t\t\treturn m\n\t\t}\n\t}\n\treturn {}\n}",
            "hasCharity": "import CharityNFT from 0xf8d6e0586b0a20c7\n\n//Check the status of a fin user\npub fun main(user: Address) : Bool {\n\tlet account=getAccount(user)\n\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\treturn charityCap.check()\n}",
            "isFindUser": "import Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\n//Check the status of a fin user\npub fun main(user: Address) : Bool {\n\n\tlet account=getAccount(user)\n\tlet leaseCap=account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\tlet profileCap=account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n\treturn leaseCap.check() \u0026\u0026 profileCap.check()\n\n}",
            "matrixworld": "import MatrixWorldVoucher from 0x0d77ec47bbad8ef6\n\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let listPrice: UFix64?\n\tpub let listToken: String?\n\tpub let contentType:String\n\tpub let rarity:String\n\n\n\tinit(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n\t\tself.id=id\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.listToken=listToken\n\t\tself.listPrice=listPrice\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\npub fun main(address: Address) : [MatrixWorldVoucher.Metadata]{\n\n\n\tlet items: [MatrixWorldVoucher.Metadata] = []\n\tlet mw = MatrixWorldVoucher.getNft(address:address)\n\tif mw.length \u003e 0 {\n\t\tfor nft in mw {\n\t\t\titems.append(nft.metadata)\n\t\t\t/*\n\t\t\tlet metadata=nft.metadata\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: nft.id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: metadata.animationUrl,\n\t\t\t\turl: \"https://matrixworld.org/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t\t*/\n\t}\n\n\t}\n\treturn items\n}",
            "name": "import FIND from 0xf8d6e0586b0a20c7\n\npub fun main(address: Address) : String?{\n\treturn FIND.reverseLookup(address)\n}",
            "nameCrawler": "import FIND from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\n\npub fun main(names: [String]) : [FIND.LeaseInformation]{\n\tlet items : [FIND.LeaseInformation]=[]\n\tfor name in names {\n\t\tlet nameStatus=FIND.status(name)\n\t\tif let address=nameStatus.owner {\n\t\t\tlet account=getAccount(address)\n\t\t\tlet leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\t\titems.append(leaseCap.borrow()!.getLease(name)!)\n\t\t} else {\n\t\t\t//free name now\n\t\t\tcontinue\n\t\t}\n\t}\n\treturn items\n}",
            "name_status": "import FIND from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\n\npub struct FINDNameReport{\n\tpub let profile:Profile.UserProfile?\n\tpub let lease: FIND.LeaseInformation?\n\tpub let status: String\n\tpub let cost: UFix64\n\tpub let leases: [FIND.LeaseInformation]\n\n\tinit(status: String, profile: Profile.UserProfile?, lease : FIND.LeaseInformation?,  cost: UFix64, leases: [FIND.LeaseInformation]) {\n\t\tself.status=status\n\t\tself.profile=profile\n\t\tself.lease=lease\n\t\tself.cost=cost\n\t\tself.leases=leases\n\t}\n}\n\n//Check the status of a fin user\npub fun main(name: String) : FINDNameReport{\n\n\tlet status=FIND.status(name)\n\tlet cost=FIND.calculateCost(name)\n\tif let address=status.owner {\n\t\tlet account=getAccount(address)\n\t\tlet leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n\t\tlet profile= account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath).borrow()\n\t\tvar lease:FIND.LeaseInformation?=nil\n\t\tif leaseCap.check() {\n\t\t\tlease=leaseCap.borrow()!.getLease(name)\n\t\t}\n\t\treturn FINDNameReport(\n\t\t\tstatus: lease?.status ?? \"taken\",\n\t\t\tprofile: profile?.asProfile(),\n\t\t\tlease: lease,\n\t\t\tcost:  cost,\n\t\t\tleases: leaseCap.borrow()?.getLeaseInformation() ?? []\n\t\t)\n\n\t}\n\n\tvar statusValue= \"FREE\"\n\tif  status.status == FIND.LeaseStatus.TAKEN {\n\t\tstatusValue=\"NO_PROFILE\"\n\t}\n\treturn FINDNameReport(\n\t\tstatus: statusValue,\n\t\tprofile: nil, \n\t\tlease: nil,\n\t\tcost: cost,\n\t\tleases: [],\n\t)\n\n}",
            "names": "import FIND from 0xf8d6e0586b0a20c7\n\npub fun main(address: [Address]) : { Address:String}{\n\n\tlet items : {Address:String} = {}\n\tfor a in address {\n\t\tif let name= FIND.reverseLookup(a) {\n\t\t\titems[a]=name\n\t\t}\n\t}\n\treturn items\n}",
            "profile": "import Profile from 0xf8d6e0586b0a20c7\n\n//Check the status of a fin user\npub fun main(address: Address) :  Profile.UserProfile? {\n\treturn getAccount(address)\n\t\t.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\t.borrow()?.asProfile()\n}",
            "remaining": "import FIND from 0xf8d6e0586b0a20c7\n\n\n//Check the status of a fin user\npub fun main(user: Address) : [String] {\n\n\tlet account=getAccount(user)\n\tlet leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n\tlet leases=leaseCap.borrow()?.getLeaseInformation() ?? []\n\n\tvar leasesWithBids :[String] =[]\n\tfor lease in leases {\n\t\tif lease.latestBidBy == nil {\n\t\t\tleasesWithBids.append(lease.name)\n\t\t}\n\t}\n\n\treturn leasesWithBids\n}",
            "reserveStatus": "import FIND from 0xf8d6e0586b0a20c7\n\n\n//Check the status of a fin user\npub fun main(user: Address) : [FIND.LeaseInformation] {\n\n\tlet account=getAccount(user)\n\tlet leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n\tlet leases=leaseCap.borrow()?.getLeaseInformation() ?? []\n\n\tvar leasesWithBids :[FIND.LeaseInformation] =[]\n\tfor lease in leases {\n\t\tif lease.latestBidBy != nil {\n\t\t\tleasesWithBids.append(lease)\n\t\t}\n\t}\n\n\treturn leasesWithBids\n}",
            "starly": "import StarlyCard from 0x5b82f21c0edf76e3\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let listPrice: UFix64?\n\tpub let listToken: String?\n\tpub let contentType:String\n\tpub let rarity:String\n\n\n\tinit(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n\t\tself.id=id\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.listToken=listToken\n\t\tself.listPrice=listPrice\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\npub fun main(address: Address) : [MetadataCollectionItem] {\n\n\n\tlet items: [MetadataCollectionItem] = []\n\tlet account=getAccount(address)\n\tlet starlyCap = account.getCapability\u003c\u0026{StarlyCard.StarlyCardCollectionPublic}\u003e(StarlyCard.CollectionPublicPath)\n\tif starlyCap.check() {\n\t\tlet collection = starlyCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowStarlyCard(id: id)!\n\n\t\t\tlet url=\"https://starly.io/c/\".concat(nft.starlyID)\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"Starly #\".concat(id.toString()),\n\t\t\t\timage: url.concat(\".json\"),\n\t\t\t\turl: url,\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"json/starly\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\titems.append(item)\n\t\t}\n\t}\n\treturn items\n\n}",
            "status": "import FIND from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\n\n//Check the status of a fin user\npub fun main(name: String) :  \u0026{Profile.Public}? {\n    return FIND.lookup(name)\n}"
         },
         "transactions": {
            "addCuratedCollection": "transaction(name: String, items: [String]) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet path=/storage/FindCuratedCollections\n\t\tlet publicPath=/public/FindCuratedCollections\n\n\t\tvar collections : {String: [String]} = {}\n\t\tif account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n\t\t\t collections=account.load\u003c{String: [String]}\u003e(from:path)!\n\t\t}\n\t\tcollections[name] = items\n\t\taccount.save(collections, to: path)\n\t\tlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n\t\tif !link.check() {\n\t\t\taccount.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n\t\t}\n\t}\n}",
            "bid": "import FIND from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\t \n\t\tlet fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount) as! @FUSD.Vault\n\t\tlet bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)!\n\t\tbids.bid(name: name, vault: \u003c- vault)\n\n\t}\n}",
            "bidProfile": "import FIND from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport Profile from 0xf8d6e0586b0a20c7\nimport FUSD from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(account: AuthAccount) {\n\n\n\t\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\taccount.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n\t\t\taccount.save(\u003c-profile, to: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount) as! @FUSD.Vault\n\t\tlet bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)!\n\t\tbids.bid(name: name, vault: \u003c- vault)\n\n\t}\n}",
            "cancelAuction": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.cancel(name)\n\t\tfinLeases.delistAuction(name)\n\n\t}\n}",
            "cancelBid": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\t\tlet bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)!\n\t\tbids.cancelBid(name)\n\t}\n}",
            "createCharity": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport CharityNFT from 0xf8d6e0586b0a20c7\n\n//This transaction will prepare the art collection\ntransaction() {\n\tprepare(account: AuthAccount) {\n\n\t\tlet stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t\tif !stdCap.check() {\n\t\t\taccount.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n\t\t\taccount.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\t\tif !charityCap.check() {\n\t\t\taccount.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\t}\n}",
            "createProfile": "import FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FIND from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\n\n\n//really not sure on how to input links here.)\ntransaction(name: String) {\n\tprepare(acct: AuthAccount) {\n\t\t//if we do not have a profile it might be stored under a different address so we will just remove it\n\t\tlet profileCap = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif profileCap.check() {\n\t\t\treturn \n\t\t}\n\n\t\tlet profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n\n\t\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\tacct.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet fusdWallet=Profile.Wallet(\n\t\t\tname:\"FUSD\", \n\t\t\treceiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver),\n\t\t\tbalance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance),\n\t\t\taccept: Type\u003c@FUSD.Vault\u003e(),\n\t\t\tnames: [\"fusd\", \"stablecoin\"]\n\t\t)\n\n\t\tprofile.addWallet(fusdWallet)\n\n\n\t\tlet flowWallet=Profile.Wallet(\n\t\t\tname:\"Flow\", \n\t\t\treceiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\tbalance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\tnames: [\"flow\"]\n\t\t)\n\t\tprofile.addWallet(flowWallet)\n\t\tlet leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n\n\t\tlet bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\t\tprofile.addCollection(Profile.ResourceCollection( \"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n\t\tacct.save(\u003c-profile, to: Profile.storagePath)\n\t\tacct.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\tacct.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\n\t}\n}",
            "delistSale": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction(name: String) {\n\tprepare(acct: AuthAccount) {\n\t\tlet finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.delistSale(name)\n\t}\n}",
            "editProfile": "import FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FIND from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\n\n\ntransaction(name:String, description: String, avatar: String, tags:[String], allowStoringFollowers: Bool, links: [{String: String}]) {\n\tprepare(acct: AuthAccount) {\n\n\t\tlet profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\n\t\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\tacct.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\n\t\tvar hasFusdWallet=false\n\t\tvar hasFlowWallet=false\n\t\tlet wallets=profile.getWallets()\n\t\tfor wallet in wallets {\n\t\t\tif wallet.name==\"FUSD\" {\n\t\t\t\thasFusdWallet=true\n\t\t\t}\n\n\t\t\tif wallet.name ==\"Flow\" {\n\t\t\t\thasFlowWallet=true\n\t\t\t}\n\t\t}\n\n\t\tif !hasFlowWallet {\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\t\tprofile.addWallet(flowWallet)\n\t\t}\n\n\t\tif !hasFusdWallet {\n\t\t\tlet fusdWallet=Profile.Wallet(\n\t\t\t\tname:\"FUSD\", \n\t\t\t\treceiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver),\n\t\t\t\tbalance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance),\n\t\t\t\taccept: Type\u003c@FUSD.Vault\u003e(),\n\t\t\t\tnames: [\"fusd\", \"stablecoin\"]\n\t\t\t)\n\t\t\tprofile.addWallet(fusdWallet)\n\t\t}\n\n\t\tprofile.setName(name)\n\t\tprofile.setDescription(description)\n\t\tprofile.setAvatar(avatar)\n\n\t\tlet existingTags=profile.setTags(tags)\n\n\t\tlet oldLinks=profile.getLinks()\n\n\t\tfor link in links {\n\t\t\tif !link.containsKey(\"title\") {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif link[\"remove\"] == \"true\" {\n\t\t\t\tprofile.removeLink(link[\"title\"]!)\t\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tprofile.addLink(Profile.Link(title: link[\"title\"]!, type: link[\"type\"]!, url: link[\"url\"]!))\n\t\t}\n\t}\n}",
            "fillUpTheChest": "// Mainnet\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\n\n// Testnet\n// import FungibleToken from 0x9a0766d93b6608b7\n// import FUSD from 0xe223d8a629e49c68\n\ntransaction() {\n\n\t// The Vault resource that holds the tokens that are being transfered\n\tlet sentVault: @FungibleToken.Vault\n\n\tprepare(signer: AuthAccount) {\n\t\t// Get a reference to the signer's stored vault\n\t\tlet vaultRef = signer.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n\t\t?? panic(\"Could not borrow reference to the owner's Vault!\")\n\n\t\t// Withdraw tokens from the signer's stored vault\n\t\tself.sentVault \u003c- vaultRef.withdraw(amount: vaultRef.balance)\n\t}\n\n\texecute {\n\n\t\tlet recipient: Address = 0x936851d3e331acd4\n\t\t// Get the recipient's public account object\n\t\tlet recipientAccount = getAccount(recipient)\n\n\t\t// Get a reference to the recipient's Receiver\n\t\tlet receiverRef = recipientAccount.getCapability(/public/fusdReceiver)!.borrow\u003c\u0026{FungibleToken.Receiver}\u003e()\n\t\t?? panic(\"Could not borrow receiver reference to the recipient's Vault\")\n\n\t\t// Deposit the withdrawn tokens in the recipient's receiver\n\t\treceiverRef.deposit(from: \u003c-self.sentVault)\n\t}\n}",
            "fulfill": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.fulfill(name)\n\n\t}\n}",
            "fulfillAuction": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction(owner: Address, name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet leaseCollection = getAccount(owner).getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tleaseCollection.borrow()!.fulfillAuction(name)\n\n\t}\n}",
            "fulfillAuctionBidder": "import FIND from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\n\ntransaction(owner: Address, name: String) {\n\tprepare(acct: AuthAccount) {\n\n\n\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\tacct.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n\t\t\tacct.save(\u003c-profile, to: Profile.storagePath)\n\t\t\tacct.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\tacct.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tlet leaseCollectionOwner = getAccount(owner).getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tleaseCollectionOwner.borrow()!.fulfillAuction(name)\n\n\t}\n}",
            "increaseBid": "import FIND from 0xf8d6e0586b0a20c7\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\t\n\t\tlet fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount) as! @FUSD.Vault\n\t\tlet bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)!\n\t\tbids.increaseBid(name: name, vault: \u003c- vault)\n\n\t}\n}",
            "listForAuction": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, auctionStartPrice: UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64) {\n\tprepare(acct: AuthAccount) {\n\t\tlet finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.listForAuction(name: name, auctionStartPrice: auctionStartPrice, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration,  auctionExtensionOnLateBid: auctionExtensionOnLateBid)\n\n\t}\n}",
            "listForSale": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, directSellPrice:UFix64) {\n\tprepare(acct: AuthAccount) {\n\t\tlet finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.listForSale(name: name,  directSellPrice:directSellPrice)\n\t}\n}",
            "moveNameToAddress": "import FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\n\ntransaction(name: String, receiverAddress:Address) {\n\n\n\tlet receiverAddress:Address\n\tlet sender : \u0026FIND.LeaseCollection\n\n\tprepare(acct: AuthAccount) {\n\t\tself.sender= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tself.receiverAddress=receiverAddress\n\t} \n\n\texecute {\n\t\tlet receiver=getAccount(self.receiverAddress)\n\t\tlet receiverLease = receiver.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tlet receiverProfile = receiver.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n\t\tif !receiverLease.check() || !receiverProfile.check() {\n\t\t\tpanic(\"Not a valid FIND user\")\n\t\t}\n\n\t\tself.sender.move(name:name, profile:receiverProfile, to: receiverLease)\n\t}\n}",
            "moveNameToName": "import FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\n\ntransaction(name: String, receiverName: String) {\n\n\n\tlet receiverAddress:Address\n\tlet sender : \u0026FIND.LeaseCollection\n\n\tprepare(acct: AuthAccount) {\n\n\t\tself.sender= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tself.receiverAddress=FIND.lookupAddress(receiverName) ?? panic(\"cannot resolve address\")\n\n\t} \n\n\texecute {\n\t\tlet receiver=getAccount(self.receiverAddress)\n\t\tlet receiverLease = receiver.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tlet receiverProfile = receiver.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n\t\tif !receiverLease.check() || !receiverProfile.check() {\n\t\t\tpanic(\"Not a valid FIND user\")\n\t\t}\n\n\t\tself.sender.move(name:name, profile:receiverProfile, to: receiverLease)\n\t}\n\n\n\n}",
            "register": "import FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(acct: AuthAccount) {\n\n\t\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\tacct.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\n\t\t}\n\n\t\tlet bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\t\t\tprofile.setFindName(name)\n\t\t\tprofile.addWallet(fusdWallet)\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n\t\t\tacct.save(\u003c-profile, to: Profile.storagePath)\n\t\t\tacct.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\tacct.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tlet price=FIND.calculateCost(name)\n\t\tif price != amount {\n\t\t\tpanic(\"Calculated cost does not match expected cost\")\n\t\t}\n\t\tlog(\"The cost for registering this name is \".concat(price.toString()))\n\n\t\tlet vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\n\t\tlet payVault \u003c- vaultRef.withdraw(amount: price) as! @FUSD.Vault\n\n\t\tlet leases=acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)!\n\t\tleases.register(name: name, vault: \u003c- payVault)\n\n\t}\n}",
            "registerGift": "import FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, amount: UFix64, recipient: Address) {\n\tprepare(acct: AuthAccount) {\n\n\t\tlet price=FIND.calculateCost(name)\n\t\tif price != amount {\n\t\t\tpanic(\"Calculated cost does not match expected cost\")\n\t\t}\n\t\tlog(\"The cost for registering this name is \".concat(price.toString()))\n\n\t\tlet vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet payVault \u003c- vaultRef.withdraw(amount: price) as! @FUSD.Vault\n\n\t\tlet leases=acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)!\n\t\tleases.register(name: name, vault: \u003c- payVault)\n\n\t\tlet receiver = getAccount(recipient)\n\t\tlet receiverLease = receiver.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tlet receiverProfile = receiver.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !receiverLease.check() {\n\t\t\tpanic(\"Receiver is not a find user\")\n\t\t}\n\t\tleases.move(name: name, profile: receiverProfile, to: receiverLease)\n\t}\n}",
            "rejectDirectOffer": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.cancel(name)\n\n\t}\n}",
            "removeCurratedCollection": "transaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet path=/storage/FindCuratedCollections\n\t\tlet publicPath=/public/FindCuratedCollections\n\n\t\tvar collections : {String: [String]} = {}\n\t\tif account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n\t\t\t collections=account.load\u003c{String: [String]}\u003e(from:path)!\n\t\t}\n\t\tcollections.remove(key: name)\n\t\taccount.save(collections, to: path)\n\t\tlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n\t\tif !link.check() {\n\t\t\taccount.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n\t\t}\n\t}\n}",
            "removeProfile": "import Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\ntransaction() {\n\tprepare(acct: AuthAccount) {\n\t\t\tacct.unlink(Profile.publicPath)\n\t\t\tdestroy \u003c- acct.load\u003c@AnyResource\u003e(from:Profile.storagePath)\n\n\t\t\tacct.unlink(FIND.BidPublicPath)\n\t\t\tdestroy \u003c- acct.load\u003c@AnyResource\u003e(from:FIND.BidStoragePath)\n\n\t\t\tacct.unlink(FIND.LeasePublicPath)\n\t\t\tdestroy \u003c- acct.load\u003c@AnyResource\u003e(from:FIND.LeaseStoragePath)\n\t}\n}",
            "removeRelatedAccount": "import RelatedAccounts from 0xf8d6e0586b0a20c7\n\n\ntransaction(name: String){\n\tprepare(account: AuthAccount) {\n\n\t\tlet cap = account.getCapability\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath)\n\t\tif !cap.check() {\n\t\t\tlet relatedAccounts \u003c- RelatedAccounts.createEmptyAccounts()\n\t\t\taccount.save(\u003c- relatedAccounts, to: RelatedAccounts.storagePath)\n\t\t\taccount.link\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath, target: RelatedAccounts.storagePath)\n\t\t}\n\n\t\tlet relatedAccounts =account.borrow\u003c\u0026RelatedAccounts.Accounts\u003e(from:RelatedAccounts.storagePath)!\n\t\trelatedAccounts.deleteAccount(name: name)\n\t}\n}",
            "renew": "import FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(acct: AuthAccount) {\n\n\t\tlet profileCap = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n\t\tlet price=FIND.calculateCost(name)\n\t\tif amount != price {\n\t\t\tpanic(\"expected renew cost is not the same as calculated renew cost\")\n\t\t}\n\t\tlet vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet payVault \u003c- vaultRef.withdraw(amount: price) as! @FUSD.Vault\n\n\t\tlet finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tlet finToken= finLeases.borrow(name)\n\t\tfinToken.extendLease(\u003c- payVault)\n\t}\n}",
            "sendCharity": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport CharityNFT from 0xf8d6e0586b0a20c7\n\n//mint an art and add it to a users collection\ntransaction(\n\tid: UInt64,\n\trecipient: Address\n) {\n\tlet receiverCap: Capability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e\n\tlet charityCollection: \u0026NonFungibleToken.Collection\n\n\tprepare(account: AuthAccount) {\n\t\tself.charityCollection =account.borrow\u003c\u0026NonFungibleToken.Collection\u003e(from: CharityNFT.CollectionStoragePath)!\n\t\tself.receiverCap= getAccount(recipient).getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t}\n\n\texecute {\n\t\tlet nft \u003c- self.charityCollection.withdraw(withdrawID: id)\n\t\tself.receiverCap.borrow()!.deposit(token: \u003c- nft)\n\t}\n}",
            "sendFT": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport Sender from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport CharityNFT from 0xf8d6e0586b0a20c7\n\n\ntransaction(name: String, amount: UFix64, type: String) {\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t\tif !stdCap.check() {\n\t\t\taccount.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n\t\t\taccount.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\t\tif !charityCap.check() {\n\t\t\taccount.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t  let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\taccount.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profileName = account.address.toString()\n\n\t\t\tlet profile \u003c-Profile.createUser(name:profileName, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n\t\t\taccount.save(\u003c-profile, to: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tif account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n\t\t\taccount.save(\u003c- Sender.create(), to: Sender.storagePath)\n\t\t}\n\n\t\tlet token =account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n\n\n\t\tif type == \"fusd\" {\n\t\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\t\tlet vault \u003c- vaultRef.withdraw(amount: amount)\n\t\t\tFIND.depositWithTagAndMessage(to: name, message: \"\", tag: \"find\", vault: \u003c- vault, from: token)\n\t\t\treturn \n\t\t}\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount)\n\t\tFIND.depositWithTagAndMessage(to: name, message: \"\", tag: \"find\", vault: \u003c- vault, from: token)\n\t}\n\n}",
            "sendFlowWithMessage": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport CharityNFT from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, amount: UFix64, message:String) {\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t\tif !stdCap.check() {\n\t\t\taccount.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n\t\t\taccount.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\t\tif !charityCap.check() {\n\t\t\taccount.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\taccount.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profileName = account.address.toString()\n\n\t\t\tlet profile \u003c-Profile.createUser(name:profileName, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n\t\t\taccount.save(\u003c-profile, to: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tlet profile =account.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\n\n\t\tlet strLength = amount.toString().length\n\t\tlet amountString = amount.toString().slice(from: 0, upTo: strLength-6)\n\t\tprofile.verify(profile.getName().concat(\" sent \").concat(amountString).concat(\" Flow with message:\").concat(message))\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tFIND.deposit(to: name, from: \u003c- vaultRef.withdraw(amount: amount))\n\t}\n}",
            "sendFlowWithTagAndMessage": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport Sender from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport CharityNFT from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, amount: UFix64, message:String, tag: String) {\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t\tif !stdCap.check() {\n\t\t\taccount.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n\t\t\taccount.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\t\tif !charityCap.check() {\n\t\t\taccount.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t  let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\taccount.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profileName = account.address.toString()\n\n\t\t\tlet profile \u003c-Profile.createUser(name:profileName, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n\t\t\taccount.save(\u003c-profile, to: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tif account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n\t\t\taccount.save(\u003c- Sender.create(), to: Sender.storagePath)\n\t\t}\n\n\t\tlet token =account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount)\n\t\tFIND.depositWithTagAndMessage(to: name, message: message, tag: tag, vault: \u003c- vault, from: token)\n\t}\n\n}",
            "sendFusdWithTagAndMessage": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport Sender from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport CharityNFT from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, amount: UFix64, message:String, tag: String) {\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t\tif !stdCap.check() {\n\t\t\taccount.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n\t\t\taccount.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\t\tif !charityCap.check() {\n\t\t\taccount.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t  let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\taccount.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profileName = account.address.toString()\n\n\t\t\tlet profile \u003c-Profile.createUser(name:profileName, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n\t\t\taccount.save(\u003c-profile, to: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tif account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n\t\t\taccount.save(\u003c- Sender.create(), to: Sender.storagePath)\n\t\t}\n\n\t\tlet token =account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount)\n\t\tFIND.depositWithTagAndMessage(to: name, message: message, tag: tag, vault: \u003c- vault, from: token)\n\t}\n\n}",
            "sendFusdWithmessage": "import NonFungibleToken from 0xf8d6e0586b0a20c7\nimport FlowToken from 0x0ae53cb6e3f42a79\nimport FungibleToken from 0xee82856bf20e2aa6\nimport FUSD from 0xf8d6e0586b0a20c7\nimport Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\nimport CharityNFT from 0xf8d6e0586b0a20c7\n\ntransaction(name: String, amount: UFix64, message:String) {\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t\tif !stdCap.check() {\n\t\t\taccount.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n\t\t\taccount.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\t\tif !charityCap.check() {\n\t\t\taccount.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t  let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\taccount.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profileName = account.address.toString()\n\n\t\t\tlet profile \u003c-Profile.createUser(name:profileName, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n\t\t\taccount.save(\u003c-profile, to: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tlet profile =account.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\n\t\tlet strLength = amount.toString().length\n\t\tlet amountString = amount.toString().slice(from: 0, upTo: strLength-6)\n\t\tprofile.verify(profile.getName().concat(\" sent \").concat(amountString).concat(\" FUSD with message:\").concat(message))\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tFIND.deposit(to: name, from: \u003c- vaultRef.withdraw(amount: amount))\n\n\t}\n\n}",
            "setMainName": "import Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\n\ntransaction(name: String) {\n\tprepare(acct: AuthAccount) {\n\n\t\tlet leaseCollectionOwner = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n\t\tif !leaseCollectionOwner.check() {\n\t\t\tpanic(\"Not a find user\")\n\t\t}\n\n\t\tif leaseCollectionOwner.borrow()!.getLease(name) == nil {\n\t\t\tpanic(\"You do not own this lease so you cannot set it as main name\")\n\t\t}\n\n\n\t\tlet profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\t\tprofile.setFindName(name)\n\t}\n}",
            "setPrivateMode": "import Profile from 0xf8d6e0586b0a20c7\nimport FIND from 0xf8d6e0586b0a20c7\n\ntransaction(mode: Bool) {\n\tprepare(acct: AuthAccount) {\n\t\tlet profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\t\tprofile.setPrivateMode(mode)\n\t}\n}",
            "setProfile": "import Profile from 0xf8d6e0586b0a20c7\n\n\ntransaction(avatar: String) {\n\tprepare(acct: AuthAccount) {\n\t\tlet profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\t\tprofile.setAvatar(avatar)\n\t}\n}",
            "setRelatedAccount": "import RelatedAccounts from 0xf8d6e0586b0a20c7\n\n\ntransaction(name: String, address: Address) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet cap = account.getCapability\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath)\n\t\tif !cap.check() {\n\t\t\tlet relatedAccounts \u003c- RelatedAccounts.createEmptyAccounts()\n\t\t\taccount.save(\u003c- relatedAccounts, to: RelatedAccounts.storagePath)\n\t\t\taccount.link\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath, target: RelatedAccounts.storagePath)\n\t\t}\n\n\t\tlet relatedAccounts =account.borrow\u003c\u0026RelatedAccounts.Accounts\u003e(from:RelatedAccounts.storagePath)!\n\t\trelatedAccounts.setFlowAccount(name: name, address: address)\n\t}\n}",
            "startAuction": "import FIND from 0xf8d6e0586b0a20c7\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.startAuction(name)\n\n\t}\n}",
            "storeCuratedCollections": "transaction(collections: {String :  [String]}) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet path=/storage/FindCuratedCollections\n\t\tlet publicPath=/public/FindCuratedCollections\n\n\t\tif account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n\t\t\t account.load\u003c{String: [String]}\u003e(from:path)\n\t\t}\n\t\taccount.save(collections, to: path)\n\n\t\tlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n\t\tif !link.check() {\n\t\t\taccount.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n\t\t}\n\t}\n}"
         }
      },
      "mainnet": {
         "scripts": {
            "address_status": "import FIND from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\nimport RelatedAccounts from 0x097bafa4e0b48eef\n\npub struct FINDReport{\n\tpub let profile:Profile.UserProfile?\n\tpub let bids: [FIND.BidInfo]\n\tpub let relatedAccounts: { String: Address}\n\tpub let leases: [FIND.LeaseInformation]\n\tpub let privateMode: Bool\n\n\tinit(profile: Profile.UserProfile?, relatedAccounts: {String: Address}, bids: [FIND.BidInfo], leases : [FIND.LeaseInformation], privateMode: Bool) {\n\t\tself.profile=profile\n\t\tself.bids=bids\n\t\tself.leases=leases\n\t\tself.relatedAccounts=relatedAccounts\n\t\tself.privateMode=privateMode\n\t}\n}\n\n//Check the status of a fin user\npub fun main(user: Address) : FINDReport{\n\n\tlet account=getAccount(user)\n\tlet bidCap = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\n\tlet leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\tlet profile=account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath).borrow()\n\treturn FINDReport(\n\t\tprofile: profile?.asProfile(),\n\t\trelatedAccounts: RelatedAccounts.findRelatedFlowAccounts(address:user),\n\t\tbids: bidCap.borrow()?.getBids() ?? [],\n\t\tleases: leaseCap.borrow()?.getLeaseInformation() ?? [],\n\t\tprivateMode: profile?.isPrivateModeEnabled() ?? false\n\t)\n\n}",
            "collections": "import NonFungibleToken from 0x1d7e57aa55817448\nimport CharityNFT from 0x097bafa4e0b48eef\n\n//mainnet\nimport Art from 0xd796ff17107bbff6\nimport Marketplace from 0xd796ff17107bbff6\nimport GooberXContract from 0x34f2bf4a80bb0f69\nimport Flovatar from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\nimport RareRooms_NFT from 0x329feb3ab062d289\nimport CNN_NFT from 0x329feb3ab062d289\nimport Canes_Vault_NFT from 0x329feb3ab062d289\nimport DGD_NFT from 0x329feb3ab062d289\nimport RaceDay_NFT from 0x329feb3ab062d289\nimport The_Next_Cartel_NFT from 0x329feb3ab062d289\nimport UFC_NFT from 0x329feb3ab062d289\nimport MotoGPCard from 0xa49cc0ee46c54bfb\nimport Gaia from 0x8b148183c28ff88f\nimport ChainmonstersRewards from 0x93615d25d14fa337\nimport Moments from 0xd4ad4740ee426334\nimport MatrixWorldFlowFestNFT from 0x2d2750f240198f91\nimport SturdyItems from 0x427ceada271aa0b1\nimport Evolution from 0xf4264ac8f3256818\nimport GeniaceNFT from 0xabda6627c70c7f52\nimport OneFootballCollectible from 0x6831760534292098\nimport CryptoPiggo from 0xd3df824bf81910a4\nimport GoatedGoatsVouchers from 0xdfc74d9d561374c0\nimport TraitPacksVouchers from 0xdfc74d9d561374c0\nimport HaikuNFT from 0xf61e40c19db2a9e2\nimport KlktnNFT from 0xabd6e80be7e9682c\nimport Mynft from 0xf6fcbef550d97aa5\n\n//xtingles\nimport Collectible from 0xf5b0eb433389ac3f\n\n\npub struct MetadataCollections {\n\n\tpub let items: {String : MetadataCollectionItem}\n\tpub let collections: {String : [String]}\n\tpub let curatedCollections: {String : [String]}\n\n\tinit(items: {String : MetadataCollectionItem}, collections: {String : [String]}, curatedCollections: {String: [String]}) {\n\t\tself.items=items\n\t\tself.collections=collections\n\t\tself.curatedCollections=curatedCollections\n\t}\n}\n\n\npub struct MetadataCollection{\n\tpub let type: String\n\tpub let items: [MetadataCollectionItem]\n\n\tinit(type:String, items: [MetadataCollectionItem]) {\n\t\tself.type=type\n\t\tself.items=items\n\t}\n}\n\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let listPrice: UFix64?\n\tpub let listToken: String?\n\tpub let contentType:String\n\tpub let rarity:String\n\n\n\tinit(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n\t\tself.id=id\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.listToken=listToken\n\t\tself.listPrice=listPrice\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\npub fun main(address: Address) : MetadataCollections? {\n\n\tlet resultMap : {String : MetadataCollectionItem} = {}\n\tlet account = getAccount(address)\n\tlet results : {String :  [String]}={}\n\n\tlet flovatarList= Flovatar.getFlovatars(address: address)\n\tlet flovatarMarketDetails = FlovatarMarketplace.getFlovatarSales(address: address)\n\tif flovatarList.length \u003e 0 || flovatarMarketDetails.length \u003e 0 {\n\t\tlet items: [String] = []\n\t\tfor flovatar in flovatarList  {\n\t\t\tvar name = flovatar.name\n\t\t\tif name == \"\" {\n\t\t\t\tname=\"Flovatar #\".concat(flovatar.id.toString())\n\t\t\t}\n\n\t\t\tvar rarity=\"common\"\n\t\t\tif flovatar.metadata.legendaryCount \u003e 0 {\n\t\t\t\trarity=\"legendary\"\n\t\t\t}else if flovatar.metadata.epicCount \u003e 0 {\n\t\t\t\trarity=\"epic\"\n\t\t\t}else if flovatar.metadata.rareCount \u003e 0 {\n\t\t\t\trarity=\"rare\"\n\t\t\t}\n\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: flovatar.id, \n\t\t\t\tname: name, \n\t\t\t\timage: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n\t\t\t\turl: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: rarity\n\t\t\t)\n\t\t\tlet itemId=\"Flovatar\".concat(flovatar.id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tfor flovatar in flovatarMarketDetails  {\n\t\t\tvar\tname=\"Flovatar #\".concat(flovatar.id.toString())\n\n\t\t\tvar rarity=\"common\"\n\t\t\tif flovatar.metadata.legendaryCount \u003e 0 {\n\t\t\t\trarity=\"legendary\"\n\t\t\t}else if flovatar.metadata.epicCount \u003e 0 {\n\t\t\t\trarity=\"epic\"\n\t\t\t}else if flovatar.metadata.rareCount \u003e 0 {\n\t\t\t\trarity=\"rare\"\n\t\t\t}\n\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: flovatar.id, \n\t\t\t\tname: name, \n\t\t\t\timage: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n\t\t\t\turl: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n\t\t\t\tlistPrice: flovatar.price,\n\t\t\t\tlistToken: \"Flow\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: rarity\n\t\t\t)\n\n\t\t\tlet itemId=\"Flovatar\".concat(flovatar.id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Flovatar\"] = items\n\t\t}\n\t}\n\n\tlet versusMarketplace = account.getCapability\u003c\u0026{Marketplace.SalePublic}\u003e(Marketplace.CollectionPublicPath)\n\tlet versusImageUrlPrefix = \"https://res.cloudinary.com/dxra4agvf/image/upload/c_fill,w_600/f_auto/maincache\"\n\tlet artList = Art.getArt(address: address)\n\tif artList.length \u003e 0 || versusMarketplace.check() {\n\t\tlet items: [String] = []\n\t\tfor art in artList {\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: art.id, \n\t\t\t\tname: art.metadata.name.concat(\" edition \").concat(art.metadata.edition.toString()).concat(\"/\").concat(art.metadata.maxEdition.toString()).concat(\" by \").concat(art.metadata.artist),  \n\t\t\t\timage: versusImageUrlPrefix.concat(art.cacheKey), \n\t\t\t\turl: \"https://www.versus.auction/piece/\".concat(address.toString()).concat(\"/\").concat(art.id.toString()).concat(\"/\"),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"Versus\".concat(art.id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\t\t}\n\t\tif versusMarketplace.check() {\n\t\t\tlet versusMarket = versusMarketplace.borrow()!.listSaleItems()\n\t\t\tfor saleItem in versusMarket {\n\t\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\t\tid: saleItem.id, \n\t\t\t\t\tname: saleItem.art.name.concat(\" edition \").concat(saleItem.art.edition.toString()).concat(\"/\").concat(saleItem.art.maxEdition.toString()).concat(\" by \").concat(saleItem.art.artist),\n\t\t\t\t\timage: versusImageUrlPrefix.concat(saleItem.cacheKey), \n\t\t\t\t\turl: \"https://www.versus.auction/listing/\".concat(saleItem.id.toString()).concat(\"/\"),\n\t\t\t\t\tlistPrice: saleItem.price,\n\t\t\t\t\tlistToken: \"Flow\",\n\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\trarity: \"\"\n\t\t\t\t)\n\n\t\t\t\tlet itemId=\"Versus\".concat(saleItem.id.toString())\n\t\t\t\titems.append(itemId)\n\t\t\t\tresultMap[itemId] = item\n\t\t\t}\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"Versus\"]= items\n\t\t}\n\t}\n\n\n\n\n\tlet goobersCap = account.getCapability\u003c\u0026GooberXContract.Collection{NonFungibleToken.CollectionPublic, GooberXContract.GooberCollectionPublic}\u003e(GooberXContract.CollectionPublicPath)\n\tif goobersCap.check() {\n\t\tlet items: [String] = []\n\t\tlet goobers = goobersCap.borrow()!.listUsersGoobers()\n\t\tfor id in goobers.keys {\n\t\t\tlet goober = goobers[id]!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"Goober #\".concat(id.toString()),\n\t\t\t\timage: goober.uri,\n\t\t\t\turl: \"https://partymansion.io/gooberz/\".concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"Gooberz\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"Gooberz\"] = items\n\t\t}\n\t}\n\n\tlet rareRoomCap = account.getCapability\u003c\u0026RareRooms_NFT.Collection{RareRooms_NFT.RareRooms_NFTCollectionPublic}\u003e(RareRooms_NFT.CollectionPublicPath)\n\tif rareRoomCap.check() {\n\t\tlet collection = rareRoomCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowRareRooms_NFT(id: id)!\n\t\t\tlet metadata = RareRooms_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://rarerooms.io/tokens/\".concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"RareRooms\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"RareRooms\"] = items\n\t\t}\n\t}\n\n\tlet cnnCap = account.getCapability\u003c\u0026CNN_NFT.Collection{CNN_NFT.CNN_NFTCollectionPublic}\u003e(CNN_NFT.CollectionPublicPath)\n\tif cnnCap.check() {\n\t\tlet collection = cnnCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowCNN_NFT(id: id)!\n\t\t\tlet metadata = CNN_NFT.getSetMetadata(setId: nft.setId)!\n\n\t\t  var image= metadata[\"preview\"]!\n\t\t\tvar contentType=\"image\"\n\t\t\t/*\n\t\t\tif metadata[\"image_file_type\"]! == \"mp4\" {\n\t\t\t\timage=metadata[\"image\"]!\n\t\t\t\tcontentType=\"video\"\n\t\t\t}\n\t\t\t*/\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: image,\n\t\t\t\turl: \"http://vault.cnn.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"CNN\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"CNN\"] = items\n\t\t}\n\t}\n\n\tlet canesVaultCap = account.getCapability\u003c\u0026Canes_Vault_NFT.Collection{Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic}\u003e(Canes_Vault_NFT.CollectionPublicPath)\n\tif canesVaultCap.check() {\n\t\tlet collection = canesVaultCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowCanes_Vault_NFT(id: id)!\n\t\t\tlet metadata = Canes_Vault_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tvar image= metadata[\"preview\"]!\n\t\t\tvar contentType=\"image\"\n\t\t\t/*\n\t\t\tif metadata[\"image_file_type\"]! == \"mp4\" {\n\t\t\t\timage=metadata[\"image\"]!\n\t\t\t\tcontentType=\"video\"\n\t\t\t}\n\t\t\t*/\n\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: image,\n\t\t\t\turl: \"https://canesvault.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"Canes_Vault_NFT\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Canes_Vault_NFT\"] = items\n\t\t}\n\t}\n\n\tlet dgdCap = account.getCapability\u003c\u0026DGD_NFT.Collection{DGD_NFT.DGD_NFTCollectionPublic}\u003e(DGD_NFT.CollectionPublicPath)\n\tif dgdCap.check() {\n\t\tlet collection = dgdCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowDGD_NFT(id: id)!\n\t\t\tlet metadata = DGD_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tvar image= metadata[\"preview\"]!\n\t\t\tvar contentType=\"image\"\n\t\t\t/*\n\t\t\tif metadata[\"image_file_type\"]! == \"mp4\" {\n\t\t\t\timage=metadata[\"image\"]!\n\t\t\t\tcontentType=\"video\"\n\t\t\t}\n\t\t\t*/\n\n\t\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: image,\n\t\t\t\turl: \"https://www.theplayerslounge.io/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"DGD_NFT\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"DGD_NFT\"] = items\n\t\t}\n\t}\n\n\tlet raceDayCap = account.getCapability\u003c\u0026RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic}\u003e(RaceDay_NFT.CollectionPublicPath)\n\tif raceDayCap.check() {\n\t\tlet collection = raceDayCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowRaceDay_NFT(id: id)!\n\t\t\tlet metadata = RaceDay_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tvar image= metadata[\"preview\"]!\n\t\t\tvar contentType=\"image\"\n\t\t\t/*\n\t\t\tif metadata[\"image_file_type\"]! == \"mp4\" {\n\t\t\t\timage=metadata[\"image\"]!\n\t\t\t\tcontentType=\"video\"\n\t\t\t}\n\t\t\t*/\n\n\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: image, \n\t\t\t\turl: \"https://www.racedaynft.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"RaceDay_NFT\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"RaceDay_NFT\"] = items\n\t\t}\n\t}\n\n\tlet nextCartelCap = account.getCapability\u003c\u0026The_Next_Cartel_NFT.Collection{The_Next_Cartel_NFT.The_Next_Cartel_NFTCollectionPublic}\u003e(The_Next_Cartel_NFT.CollectionPublicPath)\n\tif nextCartelCap.check() {\n\t\tlet collection = nextCartelCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowThe_Next_Cartel_NFT(id: id)!\n\t\t\tlet metadata = The_Next_Cartel_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tvar image= metadata[\"preview\"]!\n\t\t\tvar contentType=\"image\"\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\t// we use \"preview\" and not \"image\" because of potential .glg and .mp4 file types\n\t\t\t\timage: image,\n\t\t\t\turl: \"https://thenextcartel.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"The_Next_Cartel_NFT\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"The_Next_Cartel_NFT\"] = items\n\t\t}\n\t}\n\n\tlet ufcCap = account.getCapability\u003c\u0026UFC_NFT.Collection{UFC_NFT.UFC_NFTCollectionPublic}\u003e(UFC_NFT.CollectionPublicPath)\n\tif ufcCap.check() {\n\t\tlet collection = ufcCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowUFC_NFT(id: id)!\n\t\t\tlet metadata = UFC_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tvar image= metadata[\"image\"]!\n\t\t\tvar contentType=\"video\"\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: image,\n\t\t\t\turl: \"https://www.ufcstrike.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"UFC\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"UFC\"] = items\n\t\t}\n\t}\n\n\tlet motoGPCollection = account.getCapability\u003c\u0026MotoGPCard.Collection{MotoGPCard.ICardCollectionPublic}\u003e(/public/motogpCardCollection)\n\tif motoGPCollection.check() {\n\t\tlet motoGPNfts = motoGPCollection.borrow()!.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in motoGPNfts {\n\t\t\tlet nft = motoGPCollection.borrow()!.borrowCard(id: id)!\n\t\t\tlet metadata = nft.getCardMetadata()!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: metadata.imageUrl,\n\t\t\t\turl: \"https://motogp-ignition.com/nft/card/\".concat(id.toString()).concat(\"?owner=\").concat(address.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\n\t\t\tlet itemId=\"MotoGP\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"MotoGP\"] = items\n\t\t}\n\t}\n\n\tlet gaiaCollection = account.getCapability\u003c\u0026{Gaia.CollectionPublic}\u003e(Gaia.CollectionPublicPath)\n\tif gaiaCollection.check() {\n\n\t\tlet gaiaNfts = gaiaCollection.borrow()!.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in gaiaNfts {\n\t\t\tlet nft = gaiaCollection.borrow()!.borrowGaiaNFT(id: id)!\n\t\t\tlet metadata = Gaia.getTemplateMetaData(templateID: nft.data.templateID)!\n\n\n\t\t\t//For ballerz we can do this...\n\t\t\tvar url=\"http://ongaia.com/ballerz/\".concat(metadata[\"id\"]!)\n\t\t\tvar name=metadata[\"title\"]!\n\n\t\t\tif let seriesFullName=metadata[\"series\"] {\n\n\t\t\t\tif seriesFullName==\"Shareef O\\u{2019}Neal - Basketball\" {\n\t\t\t\t\t//If the series is basketball with shareef we can do this\n\t\t\t\t\turl=\"http://ongaia.com/sharef/\".concat(id.toString())\n\t\t\t\t\tname=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n\t\t\t\t}else if seriesFullName==\"Bryson DeChambeau - Vegas, Baby!\" {\n\t\t\t\t\t//For golf there is yet another way\n\t\t\t\t\turl=\"http://ongaia.com/bryson/\".concat(nft.data.mintNumber.toString())\n\t\t\t\t\tname=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tlet item= MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: name,\n\t\t\t\timage: metadata[\"img\"]!,\n\t\t\t\turl: url,\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"Gaia\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Gaia\"] = items\n\t\t}\n\t}\n\n\t/*\n\tlet chamonsterSeasonTable :  {UInt32: String} = {0 : \"kickstarter\", 1 : \"alpha\", 2 : \"genesis\", 4 : \"flowfest2021\" , 3: \"closedbeta\" }\n\n\tlet chainmonstersRewardsCollection = account.getCapability\u003c\u0026{ChainmonstersRewards.ChainmonstersRewardCollectionPublic}\u003e(/public/ChainmonstersRewardCollection)\n\tif chainmonstersRewardsCollection.check() {\n\t\tlet nfts = chainmonstersRewardsCollection.borrow()!.getIDs()\n\t\tlet items: [MetadataCollectionItem] = []\n\t\tfor id in nfts {\n\t\t\tlet nft = chainmonstersRewardsCollection.borrow()!.borrowReward(id: id)!\n\t\t\tlet rewardID = nft.data.rewardID\n\t\t\t// Other interesting metadata available are:\n\t\t\t// \t\t- serialNumber: nft.data.serialNumber\n\t\t\t// \t\t- totalMinted: ChainmonstersRewards.getNumRewardsMinted(rewardID: nft.data.rewardID)!\n\t\t\tlet season = ChainmonstersRewards.getRewardSeason(rewardID:nft.data.rewardID)!\n\n\t\t\tvar seasonName = chamonsterSeasonTable[season] ?? \"unknown\".concat(season.toString())\n\n\t\t\tif season == 3 \u0026\u0026 rewardID \u003c 45 {\n\t\t\t\tseasonName = \"flowfest2021\"\n\t\t\t}\n\t\t\titems.append(MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: ChainmonstersRewards.getRewardMetaData(rewardID: nft.data.rewardID)!,\n\t\t\t\timage: \"https://chainmonsters.com/images/rewards/\".concat(seasonName).concat(\"/\").concat(rewardID.toString()).concat(\".png\"),\n\t\t\t\turl: \"https://chainmonsters.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\"\n\t\t\t))\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"ChainmonstersRewards\"] = MetadataCollection(type: Type\u003c@ChainmonstersRewards.Collection\u003e().identifier, items: items)\n\t\t}\n\t}\n\t*/\n\n\tlet jambbCap = account.getCapability\u003c\u0026Moments.Collection{Moments.CollectionPublic}\u003e(Moments.CollectionPublicPath)\n\tif jambbCap.check() {\n\t\tlet nfts = jambbCap.borrow()!.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in nfts {\n\t\t\tlet nft = jambbCap.borrow()!.borrowMoment(id: id)!\n\t\t\tlet metadata=nft.getMetadata()\n\t\t\tlet item  =MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.contentName,\n\t\t\t\timage: \"ipfs://\".concat(metadata.videoHash),\n\t\t\t\turl: \"http://jambb.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"Jambb\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Jambb\"] = items\n\t\t}\n\t}\n\n\tlet mw = MatrixWorldFlowFestNFT.getNft(address:address)\n\tif mw.length \u003e 0 {\n\t\tlet items: [String] = []\n\t\tfor nft in mw {\n\t\t\tlet metadata=nft.metadata\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: nft.id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: metadata.animationUrl,\n\t\t\t\turl: \"https://matrixworld.org/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"MatrixWorldFlowFest\".concat(nft.id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"MatrixWorld\"] = items\n\t\t}\n\t}\n\n\tlet sturdyCollectionCap = account\n\t.getCapability\u003c\u0026SturdyItems.Collection{SturdyItems.SturdyItemsCollectionPublic}\u003e(SturdyItems.CollectionPublicPath)\n\tif sturdyCollectionCap.check() {\n\t\tlet sturdyNfts = sturdyCollectionCap.borrow()!.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in sturdyNfts {\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = sturdyCollectionCap.borrow()!.borrowSturdyItem(id: id)!\n\t\t\t// the only thing we can play with is the nft title which is for example:\n\t\t\t// \t- \"HOODLUM#10\"\n\t\t\t// \t- \"HOLIDAY MYSTERY BADGE 2021\"\n\t\t\t//  - \"EXCALIBUR\"\n\t\t\tlet isHoodlum = nft.tokenTitle.slice(from: 0, upTo: 7) == \"HOODLUM\"\n\t\t\tif isHoodlum {\n\t\t\t\t// the hoodlum id is needed to retrieve the image but is not in the nft\n\t\t\t\tlet hoodlumId = nft.tokenTitle.slice(from: 8, upTo: nft.tokenTitle.length)\n\t\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tname: nft.tokenTitle,\n\t\t\t\t\timage: \"https://hoodlumsnft.com/_next/image?url=%2Fthumbs%2FsomeHoodlum_\".concat(hoodlumId).concat(\".png\u0026w=1920\u0026q=75\"),\n\t\t\t\t\turl: \"https://hoodlumsnft.com/\",\n\t\t\t\t\tlistPrice:nil,\n\t\t\t\t\tlistToken:nil,\n\t\t\t\t\tcontentType:\"image\",\n\t\t\t\t\trarity: \"\"\n\t\t\t\t)\n\t\t\t\tlet itemId=\"Hoodlums\".concat(id.toString())\n\t\t\t\titems.append(itemId)\n\t\t\t\tresultMap[itemId] = item\n\t\t\t}\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"Hoodlums\"] = items\n\t\t}\n\t}\n\n\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\tif charityCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = charityCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowCharity(id: id)!\n\t\t\tlet metadata = nft.getMetadata()\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: metadata[\"thumbnail\"]!,\n\t\t\t\turl: metadata[\"originUrl\"]!,\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType:\"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"Charity\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"Find\"] = items\n\t\t}\n\t}\n\n\tlet evolutionCap=account.getCapability\u003c\u0026{Evolution.EvolutionCollectionPublic}\u003e(/public/f4264ac8f3256818_Evolution_Collection)\n\tif evolutionCap.check() {\n\t\tlet evolution=evolutionCap.borrow()!\n\t\tlet nfts = evolution.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in nfts{\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = evolution.borrowCollectible(id: id)!\n\t\t\tlet metadata = Evolution.getItemMetadata(itemId: nft.data.itemId)!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"Title\"]!.concat(\" #\").concat(nft.data.serialNumber.toString()),\n\t\t\t\timage: \"https://storage.viv3.com/0xf4264ac8f3256818/mv/\".concat(nft.data.itemId.toString()),\n\t\t\t\turl: \"https://www.evolution-collect.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType:\"video\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"Evolution\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Evolution\"] = items\n\t\t}\n\t}\n\n\n\tlet geniaceCap = account.getCapability\u003c\u0026GeniaceNFT.Collection{NonFungibleToken.CollectionPublic, GeniaceNFT.GeniaceNFTCollectionPublic}\u003e(GeniaceNFT.CollectionPublicPath)\n\tif geniaceCap.check() {\n\t\tlet geniace=geniaceCap.borrow()!\n\t\tlet nfts = geniace.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in nfts{\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = geniace.borrowGeniaceNFT(id: id)!\n\t\t\tlet metadata = nft.metadata\n\t\t\tvar rarity=\"\"\n\t\t\tif metadata.rarity == GeniaceNFT.Rarity.Collectible {\n\t\t\t\trarity=\"Collectible\"\n\t\t\t}else if metadata.rarity == GeniaceNFT.Rarity.Rare {\n\t\t\t\trarity=\"Rare\"\n\t\t\t}else if metadata.rarity == GeniaceNFT.Rarity.UltraRare {\n\t\t\t\trarity=\"UltraRare\"\n\t\t\t}\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: metadata.imageUrl,\n\t\t\t\turl: \"https://www.geniace.com/product/\".concat(metadata.name),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: metadata.data[\"mimetype\"]!,\n\t\t\t\trarity: rarity,\n\t\t\t)\n\n\t\t\tlet itemId=\"Geniace\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Geniace\"] = items\n\t\t}\n\t}\n\n\t// https://flow-view-source.com/mainnet/account/0x6831760534292098/contract/OneFootballCollectible\n\tlet oneFootballCollectibleCap = account.getCapability\u003c\u0026OneFootballCollectible.Collection{OneFootballCollectible.OneFootballCollectibleCollectionPublic}\u003e(OneFootballCollectible.CollectionPublicPath)\n\tif oneFootballCollectibleCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = oneFootballCollectibleCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowOneFootballCollectible(id: id)!\n\t\t\tlet metadata = nft.getTemplate()!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: \"ipfs://\".concat(metadata.media),\n\t\t\t\turl: \"https://xmas.onefootball.com/\".concat(account.address.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\tlet itemId=\"OneFootballCollectible\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"OneFootballCollectible\"] = items\n\t\t}\n\t}\n\n\n\tlet cryptoPiggoCap = account.getCapability\u003c\u0026{CryptoPiggo.CryptoPiggoCollectionPublic}\u003e(CryptoPiggo.CollectionPublicPath)\n\tif cryptoPiggoCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = cryptoPiggoCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowItem(id: id)!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"CryptoPiggo #\".concat(id.toString()),\n\t\t\t\timage: \"https://s3.us-west-2.amazonaws.com/crypto-piggo.nft/piggo-\".concat(id.toString()).concat(\".png\"),\n\t\t\t\turl: \"https://rareworx.com/piggo/details/\".concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\tlet itemId=\"CryptoPiggo\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"CryptoPiggo\"] = items\n\t\t}\n\t}\n\n\tlet xtingles = Collectible.getCollectibleDatas(address:address) \n\tif xtingles.length \u003e 0 {\n\t\tlet items: [String] = []\n\t\tfor nft in xtingles {\n\n\t\t\tvar image=nft.metadata.link\n\n\t\t\tlet prefix=\"https://\"\n\t\t\tif image.slice(from:0, upTo:prefix.length) != prefix {\n\t\t\t\timage=\"ipfs://\".concat(image)\n\t\t\t}\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: nft.id,\n\t\t\t\tname: nft.metadata.name.concat(\" #\").concat(nft.metadata.edition.toString()),\n\t\t\t\timage: image,\n\t\t\t\turl: \"http://xtingles.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"Xtingles\".concat(nft.id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"Xtingles\"] = items\n\t\t}\n\t}\n\n\tlet goatsCap = account.getCapability\u003c\u0026{GoatedGoatsVouchers.GoatsVoucherCollectionPublic}\u003e(GoatedGoatsVouchers.CollectionPublicPath)\n\tvar goats : [String]=[]\n\tif goatsCap.check() {\n\t\tlet goatsImageUrl= GoatedGoatsVouchers.getCollectionMetadata()[\"mediaURL\"]!\n\t\tlet collection = goatsCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"Goated Goat Base Goat Voucher #\".concat(id.toString()),\n\t\t\t\timage: goatsImageUrl, \n\t\t\t\turl: \"https://goatedgoats.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\tlet itemId=\"GoatedGoatsVoucher\".concat(id.toString())\n\t\t\tgoats.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\n\n\tlet goatsTraitCap = account.getCapability\u003c\u0026{TraitPacksVouchers.PackVoucherCollectionPublic}\u003e(TraitPacksVouchers.CollectionPublicPath)\n\tif goatsTraitCap.check() {\n\t\tlet goatsImageUrl= TraitPacksVouchers.getCollectionMetadata()[\"mediaURL\"]!\n\t\tlet collection = goatsTraitCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"Goated Goat Trait Pack Voucher #\".concat(id.toString()),\n\t\t\t\timage: goatsImageUrl, \n\t\t\t\turl: \"https://goatedgoats.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\tlet itemId=\"GoatedGoatsTraitVoucher\".concat(id.toString())\n\t\t\tgoats.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\n\tif goats.length != 0 {\n\t\t\tresults[\"GoatedGoats\"] = goats\n\t}\n\n  let bitkuCap = account.getCapability\u003c\u0026{HaikuNFT.HaikuCollectionPublic}\u003e(HaikuNFT.HaikuCollectionPublicPath)\n\tif bitkuCap.check() {\n\t\tlet collection = bitkuCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowHaiku(id: id)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"Bitku #\".concat(id.toString()),\n\t\t\t\timage: nft.text,\n\t\t\t\turl: \"https://bitku.art/#\".concat(address.toString()).concat(\"/\").concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"text\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"BitKu\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"BitKu\"] = items\n\t\t}\n\t}\n\tlet klktnCap = account.getCapability\u003c\u0026{KlktnNFT.KlktnNFTCollectionPublic}\u003e(KlktnNFT.CollectionPublicPath)\n\tif klktnCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = klktnCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowKlktnNFT(id: id)!\n\n\t\t\tlet metadata=nft.getNFTMetadata()\n\t\t\t/*\n\n\t\t\tResult: {\"uri\": \"ipfs://bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym\", \"name\": \"Kevin Woo - What is KLKTN?\", \"mimeType\": \"video/mp4\", \"media\": \"https://ipfs.io/ipfs/bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym/fb91ad34d61dde04f02ad240f0ca924902d8b4a3da25daaf0bb1ed769977848c.mp4\", \"description\": \"K-pop sensation Kevin Woo has partnered up with KLKTN to enhance his artist to fan interactions and experiences within his fandom. Join our chat to learn more: https://discord.gg/UJxb4erfUw\"}\n\n\t\t\t*/\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: metadata[\"media\"]!,\n\t\t\t\turl: \"https://klktn.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"video\", //metadata[\"mimeType\"]!,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t    let itemId=\"KLKTN\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"KLKTN\"] = items\n\t\t}\n\t}\n\n\tlet mynftCap = account.getCapability\u003c\u0026{Mynft.MynftCollectionPublic}\u003e(Mynft.CollectionPublicPath)\n\tif mynftCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = mynftCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowArt(id: id)!\n\t\t\tlet metadata=nft.metadata\n\n\t\t\tvar image= metadata.ipfsLink\n\t\t\tif image == \"\" {\n\t\t\t\timage=\"https://arweave.net/\".concat(metadata.arLink)\n\t\t\t}\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: image,\n\t\t\t\turl: \"http://mynft.io\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n      let itemId=\"mynft\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"mynft\"] = items\n\t\t}\n\t}\n\n\tif results.keys.length == 0 {\n\t\treturn nil\n\t}\n\n\tlet publicPath=/public/FindCuratedCollections\n\tlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n\tvar curatedCollections : {String: [String]} = {}\n\tif link.check() {\n\t\tlet curated = link.borrow()!\n\t\tfor curatedKey in curated.keys {\n\t\t\tcuratedCollections[curatedKey] = curated[curatedKey]!\n\t\t}\n\t}\n\n\treturn MetadataCollections(items: resultMap, collections:results, curatedCollections: curatedCollections)\n}",
            "curatedCollections": "pub fun main(address: Address) : \u0026{String: [String]}? {\n\tlet account=getAccount(address)\n\tlet publicPath=/public/FindCuratedCollections\n\tlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n\tif link.check() {\n\t\treturn link.borrow()\n\t}\n\treturn nil\n}",
            "flobits": "import FlovatarComponent from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let listPrice: UFix64?\n\tpub let listToken: String?\n\tpub let contentType:String\n\tpub let rarity:String\n\n\n\tinit(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n\t\tself.id=id\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.listToken=listToken\n\t\tself.listPrice=listPrice\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\npub fun main(addr: Address) : [MetadataCollectionItem] {\n\n\tlet flovatarComponents= FlovatarComponent.getComponents(address: addr)\n\n\tlet templateNumbers : {UInt64: UInt64} = {}\n\tlet templateData : {UInt64: FlovatarComponent.ComponentData} = {}\n\tfor flovatar in flovatarComponents {\n\n\t\tlet templateId= flovatar.templateId\n\t\tvar number:UInt64=1\n\t\tif templateNumbers[templateId] == nil {\n\t\t\ttemplateNumbers[templateId] = (1 as UInt64)\n\t\t\ttemplateData[templateId]=flovatar\n\t\t} else {\n\t\t\ttemplateNumbers[templateId] = templateNumbers[templateId]! + 1\n\t\t}\n\t}\n\n\n\tlet flovatarMarketComponents=FlovatarMarketplace.getFlovatarComponentSales(address:addr)\n\n\tfor flovatar in flovatarMarketComponents {\n\n\t\tlet templateId= flovatar.metadata.templateId\n\t\t\tvar number:UInt64=1\n\t\t\tif templateNumbers[templateId] == nil {\n\t\t\t\ttemplateNumbers[templateId] = (1 as UInt64)\n\t\t\t\ttemplateData[templateId]=FlovatarComponent.getComponent(address:addr, componentId: flovatar.id)!\n\t\t\t} else {\n\t\t\t\ttemplateNumbers[templateId] = templateNumbers[templateId]! + 1\n\t\t\t}\n\t}\n\n\n\tlet flovatarC : [MetadataCollectionItem] = []\n\tfor templateId in templateData.keys {\n\t\tlet template=templateData[templateId]!\n\n\n\t\tvar name=template.name\n\n\t\tif templateId == 75 || templateId==74 || templateId == 73 {\n\t\t\tname=name.concat(\" Booster\")\n\t\t}\n\n\t\tif templateNumbers[templateId]! \u003e 1 {\n\t\t\tname=name.concat(\" x \").concat(templateNumbers[templateId]!.toString())\n\t\t} \n\n\t\tlet item=MetadataCollectionItem(\n\t\t\tid: template.id, \n\t\t\tname: name, \n\t\t\timage: \"https://flovatar.com/api/image/template/\".concat(templateId.toString()),\n\t\t\turl: \"https://flovatar.com\",\n\t\t\tlistPrice: nil,\n\t\t\tlistToken: nil,\n\t\t\tcontentType: \"image\",\n\t\t\trarity: template.rarity\n\t\t)\n\n\t\tflovatarC.append(item)\n\t}\n\n\treturn flovatarC\n\n}",
            "gg": "import GoatedGoatsVouchers from 0xdfc74d9d561374c0\n\npub fun main(addr: Address) : {String:String} {\n\n\tlet account=getAccount(addr)\n\n\tlet goatedGoatsCap = account.getCapability\u003c\u0026{GoatedGoatsVouchers.GoatsVoucherCollectionPublic}\u003e(GoatedGoatsVouchers.CollectionPublicPath)\n\tif goatedGoatsCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection=goatedGoatsCap.borrow()!\n\t\tlet goats = collection.getIDs()\n\t\tfor id in goats {\n\n\t\t\tlet i = collection.borrowVoucher(id:id)!\n\t\t\tlet m = i.getMetadata()\n\t\t\tm[\"id\"] = id.toString()\n\t\t\treturn m\n\t\t}\n\t}\n\treturn {}\n}",
            "hasCharity": "import CharityNFT from 0x097bafa4e0b48eef\n\n//Check the status of a fin user\npub fun main(user: Address) : Bool {\n\tlet account=getAccount(user)\n\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\treturn charityCap.check()\n}",
            "isFindUser": "import Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\n//Check the status of a fin user\npub fun main(user: Address) : Bool {\n\n\tlet account=getAccount(user)\n\tlet leaseCap=account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\tlet profileCap=account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n\treturn leaseCap.check() \u0026\u0026 profileCap.check()\n\n}",
            "matrixworld": "import MatrixWorldVoucher from 0x0d77ec47bbad8ef6\n\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let listPrice: UFix64?\n\tpub let listToken: String?\n\tpub let contentType:String\n\tpub let rarity:String\n\n\n\tinit(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n\t\tself.id=id\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.listToken=listToken\n\t\tself.listPrice=listPrice\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\npub fun main(address: Address) : [MatrixWorldVoucher.Metadata]{\n\n\n\tlet items: [MatrixWorldVoucher.Metadata] = []\n\tlet mw = MatrixWorldVoucher.getNft(address:address)\n\tif mw.length \u003e 0 {\n\t\tfor nft in mw {\n\t\t\titems.append(nft.metadata)\n\t\t\t/*\n\t\t\tlet metadata=nft.metadata\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: nft.id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: metadata.animationUrl,\n\t\t\t\turl: \"https://matrixworld.org/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t\t*/\n\t}\n\n\t}\n\treturn items\n}",
            "name": "import FIND from 0x097bafa4e0b48eef\n\npub fun main(address: Address) : String?{\n\treturn FIND.reverseLookup(address)\n}",
            "nameCrawler": "import FIND from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\n\npub fun main(names: [String]) : [FIND.LeaseInformation]{\n\tlet items : [FIND.LeaseInformation]=[]\n\tfor name in names {\n\t\tlet nameStatus=FIND.status(name)\n\t\tif let address=nameStatus.owner {\n\t\t\tlet account=getAccount(address)\n\t\t\tlet leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\t\titems.append(leaseCap.borrow()!.getLease(name)!)\n\t\t} else {\n\t\t\t//free name now\n\t\t\tcontinue\n\t\t}\n\t}\n\treturn items\n}",
            "name_status": "import FIND from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\n\npub struct FINDNameReport{\n\tpub let profile:Profile.UserProfile?\n\tpub let lease: FIND.LeaseInformation?\n\tpub let status: String\n\tpub let cost: UFix64\n\tpub let leases: [FIND.LeaseInformation]\n\n\tinit(status: String, profile: Profile.UserProfile?, lease : FIND.LeaseInformation?,  cost: UFix64, leases: [FIND.LeaseInformation]) {\n\t\tself.status=status\n\t\tself.profile=profile\n\t\tself.lease=lease\n\t\tself.cost=cost\n\t\tself.leases=leases\n\t}\n}\n\n//Check the status of a fin user\npub fun main(name: String) : FINDNameReport{\n\n\tlet status=FIND.status(name)\n\tlet cost=FIND.calculateCost(name)\n\tif let address=status.owner {\n\t\tlet account=getAccount(address)\n\t\tlet leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n\t\tlet profile= account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath).borrow()\n\t\tvar lease:FIND.LeaseInformation?=nil\n\t\tif leaseCap.check() {\n\t\t\tlease=leaseCap.borrow()!.getLease(name)\n\t\t}\n\t\treturn FINDNameReport(\n\t\t\tstatus: lease?.status ?? \"taken\",\n\t\t\tprofile: profile?.asProfile(),\n\t\t\tlease: lease,\n\t\t\tcost:  cost,\n\t\t\tleases: leaseCap.borrow()?.getLeaseInformation() ?? []\n\t\t)\n\n\t}\n\n\tvar statusValue= \"FREE\"\n\tif  status.status == FIND.LeaseStatus.TAKEN {\n\t\tstatusValue=\"NO_PROFILE\"\n\t}\n\treturn FINDNameReport(\n\t\tstatus: statusValue,\n\t\tprofile: nil, \n\t\tlease: nil,\n\t\tcost: cost,\n\t\tleases: [],\n\t)\n\n}",
            "names": "import FIND from 0x097bafa4e0b48eef\n\npub fun main(address: [Address]) : { Address:String}{\n\n\tlet items : {Address:String} = {}\n\tfor a in address {\n\t\tif let name= FIND.reverseLookup(a) {\n\t\t\titems[a]=name\n\t\t}\n\t}\n\treturn items\n}",
            "profile": "import Profile from 0x097bafa4e0b48eef\n\n//Check the status of a fin user\npub fun main(address: Address) :  Profile.UserProfile? {\n\treturn getAccount(address)\n\t\t.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\t.borrow()?.asProfile()\n}",
            "remaining": "import FIND from 0x097bafa4e0b48eef\n\n\n//Check the status of a fin user\npub fun main(user: Address) : [String] {\n\n\tlet account=getAccount(user)\n\tlet leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n\tlet leases=leaseCap.borrow()?.getLeaseInformation() ?? []\n\n\tvar leasesWithBids :[String] =[]\n\tfor lease in leases {\n\t\tif lease.latestBidBy == nil {\n\t\t\tleasesWithBids.append(lease.name)\n\t\t}\n\t}\n\n\treturn leasesWithBids\n}",
            "reserveStatus": "import FIND from 0x097bafa4e0b48eef\n\n\n//Check the status of a fin user\npub fun main(user: Address) : [FIND.LeaseInformation] {\n\n\tlet account=getAccount(user)\n\tlet leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n\tlet leases=leaseCap.borrow()?.getLeaseInformation() ?? []\n\n\tvar leasesWithBids :[FIND.LeaseInformation] =[]\n\tfor lease in leases {\n\t\tif lease.latestBidBy != nil {\n\t\t\tleasesWithBids.append(lease)\n\t\t}\n\t}\n\n\treturn leasesWithBids\n}",
            "starly": "import StarlyCard from 0x5b82f21c0edf76e3\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let listPrice: UFix64?\n\tpub let listToken: String?\n\tpub let contentType:String\n\tpub let rarity:String\n\n\n\tinit(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n\t\tself.id=id\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.listToken=listToken\n\t\tself.listPrice=listPrice\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\npub fun main(address: Address) : [MetadataCollectionItem] {\n\n\n\tlet items: [MetadataCollectionItem] = []\n\tlet account=getAccount(address)\n\tlet starlyCap = account.getCapability\u003c\u0026{StarlyCard.StarlyCardCollectionPublic}\u003e(StarlyCard.CollectionPublicPath)\n\tif starlyCap.check() {\n\t\tlet collection = starlyCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowStarlyCard(id: id)!\n\n\t\t\tlet url=\"https://starly.io/c/\".concat(nft.starlyID)\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"Starly #\".concat(id.toString()),\n\t\t\t\timage: url.concat(\".json\"),\n\t\t\t\turl: url,\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"json/starly\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\titems.append(item)\n\t\t}\n\t}\n\treturn items\n\n}",
            "status": "import FIND from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\n\n//Check the status of a fin user\npub fun main(name: String) :  \u0026{Profile.Public}? {\n    return FIND.lookup(name)\n}"
         },
         "transactions": {
            "addCuratedCollection": "transaction(name: String, items: [String]) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet path=/storage/FindCuratedCollections\n\t\tlet publicPath=/public/FindCuratedCollections\n\n\t\tvar collections : {String: [String]} = {}\n\t\tif account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n\t\t\t collections=account.load\u003c{String: [String]}\u003e(from:path)!\n\t\t}\n\t\tcollections[name] = items\n\t\taccount.save(collections, to: path)\n\t\tlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n\t\tif !link.check() {\n\t\t\taccount.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n\t\t}\n\t}\n}",
            "bid": "import FIND from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\t \n\t\tlet fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount) as! @FUSD.Vault\n\t\tlet bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)!\n\t\tbids.bid(name: name, vault: \u003c- vault)\n\n\t}\n}",
            "bidProfile": "import FIND from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport Profile from 0x097bafa4e0b48eef\nimport FUSD from 0x3c5959b568896393\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(account: AuthAccount) {\n\n\n\t\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\taccount.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n\t\t\taccount.save(\u003c-profile, to: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount) as! @FUSD.Vault\n\t\tlet bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)!\n\t\tbids.bid(name: name, vault: \u003c- vault)\n\n\t}\n}",
            "cancelAuction": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.cancel(name)\n\t\tfinLeases.delistAuction(name)\n\n\t}\n}",
            "cancelBid": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\t\tlet bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)!\n\t\tbids.cancelBid(name)\n\t}\n}",
            "createCharity": "import NonFungibleToken from 0x1d7e57aa55817448\nimport CharityNFT from 0x097bafa4e0b48eef\n\n//This transaction will prepare the art collection\ntransaction() {\n\tprepare(account: AuthAccount) {\n\n\t\tlet stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t\tif !stdCap.check() {\n\t\t\taccount.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n\t\t\taccount.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\t\tif !charityCap.check() {\n\t\t\taccount.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\t}\n}",
            "createProfile": "import FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport FlowToken from 0x1654653399040a61\nimport FIND from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\n\n\n//really not sure on how to input links here.)\ntransaction(name: String) {\n\tprepare(acct: AuthAccount) {\n\t\t//if we do not have a profile it might be stored under a different address so we will just remove it\n\t\tlet profileCap = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif profileCap.check() {\n\t\t\treturn \n\t\t}\n\n\t\tlet profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n\n\t\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\tacct.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet fusdWallet=Profile.Wallet(\n\t\t\tname:\"FUSD\", \n\t\t\treceiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver),\n\t\t\tbalance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance),\n\t\t\taccept: Type\u003c@FUSD.Vault\u003e(),\n\t\t\tnames: [\"fusd\", \"stablecoin\"]\n\t\t)\n\n\t\tprofile.addWallet(fusdWallet)\n\n\n\t\tlet flowWallet=Profile.Wallet(\n\t\t\tname:\"Flow\", \n\t\t\treceiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\tbalance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\tnames: [\"flow\"]\n\t\t)\n\t\tprofile.addWallet(flowWallet)\n\t\tlet leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n\n\t\tlet bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\t\tprofile.addCollection(Profile.ResourceCollection( \"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n\t\tacct.save(\u003c-profile, to: Profile.storagePath)\n\t\tacct.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\tacct.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\n\t}\n}",
            "delistSale": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String) {\n\tprepare(acct: AuthAccount) {\n\t\tlet finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.delistSale(name)\n\t}\n}",
            "editProfile": "import FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport FlowToken from 0x1654653399040a61\nimport FIND from 0x097bafa4e0b48eef\nimport Profile from 0x097bafa4e0b48eef\n\n\ntransaction(name:String, description: String, avatar: String, tags:[String], allowStoringFollowers: Bool, links: [{String: String}]) {\n\tprepare(acct: AuthAccount) {\n\n\t\tlet profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\n\t\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\tacct.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\n\t\tvar hasFusdWallet=false\n\t\tvar hasFlowWallet=false\n\t\tlet wallets=profile.getWallets()\n\t\tfor wallet in wallets {\n\t\t\tif wallet.name==\"FUSD\" {\n\t\t\t\thasFusdWallet=true\n\t\t\t}\n\n\t\t\tif wallet.name ==\"Flow\" {\n\t\t\t\thasFlowWallet=true\n\t\t\t}\n\t\t}\n\n\t\tif !hasFlowWallet {\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\t\tprofile.addWallet(flowWallet)\n\t\t}\n\n\t\tif !hasFusdWallet {\n\t\t\tlet fusdWallet=Profile.Wallet(\n\t\t\t\tname:\"FUSD\", \n\t\t\t\treceiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver),\n\t\t\t\tbalance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance),\n\t\t\t\taccept: Type\u003c@FUSD.Vault\u003e(),\n\t\t\t\tnames: [\"fusd\", \"stablecoin\"]\n\t\t\t)\n\t\t\tprofile.addWallet(fusdWallet)\n\t\t}\n\n\t\tprofile.setName(name)\n\t\tprofile.setDescription(description)\n\t\tprofile.setAvatar(avatar)\n\n\t\tlet existingTags=profile.setTags(tags)\n\n\t\tlet oldLinks=profile.getLinks()\n\n\t\tfor link in links {\n\t\t\tif !link.containsKey(\"title\") {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif link[\"remove\"] == \"true\" {\n\t\t\t\tprofile.removeLink(link[\"title\"]!)\t\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tprofile.addLink(Profile.Link(title: link[\"title\"]!, type: link[\"type\"]!, url: link[\"url\"]!))\n\t\t}\n\t}\n}",
            "fillUpTheChest": "// Mainnet\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\n\n// Testnet\n// import FungibleToken from 0x9a0766d93b6608b7\n// import FUSD from 0xe223d8a629e49c68\n\ntransaction() {\n\n\t// The Vault resource that holds the tokens that are being transfered\n\tlet sentVault: @FungibleToken.Vault\n\n\tprepare(signer: AuthAccount) {\n\t\t// Get a reference to the signer's stored vault\n\t\tlet vaultRef = signer.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n\t\t?? panic(\"Could not borrow reference to the owner's Vault!\")\n\n\t\t// Withdraw tokens from the signer's stored vault\n\t\tself.sentVault \u003c- vaultRef.withdraw(amount: vaultRef.balance)\n\t}\n\n\texecute {\n\n\t\tlet recipient: Address = 0x936851d3e331acd4\n\t\t// Get the recipient's public account object\n\t\tlet recipientAccount = getAccount(recipient)\n\n\t\t// Get a reference to the recipient's Receiver\n\t\tlet receiverRef = recipientAccount.getCapability(/public/fusdReceiver)!.borrow\u003c\u0026{FungibleToken.Receiver}\u003e()\n\t\t?? panic(\"Could not borrow receiver reference to the recipient's Vault\")\n\n\t\t// Deposit the withdrawn tokens in the recipient's receiver\n\t\treceiverRef.deposit(from: \u003c-self.sentVault)\n\t}\n}",
            "fulfill": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.fulfill(name)\n\n\t}\n}",
            "fulfillAuction": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(owner: Address, name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet leaseCollection = getAccount(owner).getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tleaseCollection.borrow()!.fulfillAuction(name)\n\n\t}\n}",
            "fulfillAuctionBidder": "import FIND from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport Profile from 0x097bafa4e0b48eef\n\ntransaction(owner: Address, name: String) {\n\tprepare(acct: AuthAccount) {\n\n\n\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\tacct.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n\t\t\tacct.save(\u003c-profile, to: Profile.storagePath)\n\t\t\tacct.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\tacct.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tlet leaseCollectionOwner = getAccount(owner).getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tleaseCollectionOwner.borrow()!.fulfillAuction(name)\n\n\t}\n}",
            "increaseBid": "import FIND from 0x097bafa4e0b48eef\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\t\n\t\tlet fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount) as! @FUSD.Vault\n\t\tlet bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)!\n\t\tbids.increaseBid(name: name, vault: \u003c- vault)\n\n\t}\n}",
            "listForAuction": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String, auctionStartPrice: UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64) {\n\tprepare(acct: AuthAccount) {\n\t\tlet finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.listForAuction(name: name, auctionStartPrice: auctionStartPrice, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration,  auctionExtensionOnLateBid: auctionExtensionOnLateBid)\n\n\t}\n}",
            "listForSale": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String, directSellPrice:UFix64) {\n\tprepare(acct: AuthAccount) {\n\t\tlet finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.listForSale(name: name,  directSellPrice:directSellPrice)\n\t}\n}",
            "moveNameToAddress": "import FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport FlowToken from 0x1654653399040a61\nimport Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\n\ntransaction(name: String, receiverAddress:Address) {\n\n\n\tlet receiverAddress:Address\n\tlet sender : \u0026FIND.LeaseCollection\n\n\tprepare(acct: AuthAccount) {\n\t\tself.sender= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tself.receiverAddress=receiverAddress\n\t} \n\n\texecute {\n\t\tlet receiver=getAccount(self.receiverAddress)\n\t\tlet receiverLease = receiver.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tlet receiverProfile = receiver.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n\t\tif !receiverLease.check() || !receiverProfile.check() {\n\t\t\tpanic(\"Not a valid FIND user\")\n\t\t}\n\n\t\tself.sender.move(name:name, profile:receiverProfile, to: receiverLease)\n\t}\n}",
            "moveNameToName": "import FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport FlowToken from 0x1654653399040a61\nimport Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\n\ntransaction(name: String, receiverName: String) {\n\n\n\tlet receiverAddress:Address\n\tlet sender : \u0026FIND.LeaseCollection\n\n\tprepare(acct: AuthAccount) {\n\n\t\tself.sender= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tself.receiverAddress=FIND.lookupAddress(receiverName) ?? panic(\"cannot resolve address\")\n\n\t} \n\n\texecute {\n\t\tlet receiver=getAccount(self.receiverAddress)\n\t\tlet receiverLease = receiver.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tlet receiverProfile = receiver.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n\t\tif !receiverLease.check() || !receiverProfile.check() {\n\t\t\tpanic(\"Not a valid FIND user\")\n\t\t}\n\n\t\tself.sender.move(name:name, profile:receiverProfile, to: receiverLease)\n\t}\n\n\n\n}",
            "register": "import FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport FlowToken from 0x1654653399040a61\nimport Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(acct: AuthAccount) {\n\n\t\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\tacct.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\n\t\t}\n\n\t\tlet bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\t\t\tprofile.setFindName(name)\n\t\t\tprofile.addWallet(fusdWallet)\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n\t\t\tacct.save(\u003c-profile, to: Profile.storagePath)\n\t\t\tacct.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\tacct.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tlet price=FIND.calculateCost(name)\n\t\tif price != amount {\n\t\t\tpanic(\"Calculated cost does not match expected cost\")\n\t\t}\n\t\tlog(\"The cost for registering this name is \".concat(price.toString()))\n\n\t\tlet vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\n\t\tlet payVault \u003c- vaultRef.withdraw(amount: price) as! @FUSD.Vault\n\n\t\tlet leases=acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)!\n\t\tleases.register(name: name, vault: \u003c- payVault)\n\n\t}\n}",
            "registerGift": "import FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport FlowToken from 0x1654653399040a61\nimport Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String, amount: UFix64, recipient: Address) {\n\tprepare(acct: AuthAccount) {\n\n\t\tlet price=FIND.calculateCost(name)\n\t\tif price != amount {\n\t\t\tpanic(\"Calculated cost does not match expected cost\")\n\t\t}\n\t\tlog(\"The cost for registering this name is \".concat(price.toString()))\n\n\t\tlet vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet payVault \u003c- vaultRef.withdraw(amount: price) as! @FUSD.Vault\n\n\t\tlet leases=acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)!\n\t\tleases.register(name: name, vault: \u003c- payVault)\n\n\t\tlet receiver = getAccount(recipient)\n\t\tlet receiverLease = receiver.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tlet receiverProfile = receiver.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !receiverLease.check() {\n\t\t\tpanic(\"Receiver is not a find user\")\n\t\t}\n\t\tleases.move(name: name, profile: receiverProfile, to: receiverLease)\n\t}\n}",
            "rejectDirectOffer": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.cancel(name)\n\n\t}\n}",
            "removeCurratedCollection": "transaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet path=/storage/FindCuratedCollections\n\t\tlet publicPath=/public/FindCuratedCollections\n\n\t\tvar collections : {String: [String]} = {}\n\t\tif account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n\t\t\t collections=account.load\u003c{String: [String]}\u003e(from:path)!\n\t\t}\n\t\tcollections.remove(key: name)\n\t\taccount.save(collections, to: path)\n\t\tlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n\t\tif !link.check() {\n\t\t\taccount.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n\t\t}\n\t}\n}",
            "removeProfile": "import Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction() {\n\tprepare(acct: AuthAccount) {\n\t\t\tacct.unlink(Profile.publicPath)\n\t\t\tdestroy \u003c- acct.load\u003c@AnyResource\u003e(from:Profile.storagePath)\n\n\t\t\tacct.unlink(FIND.BidPublicPath)\n\t\t\tdestroy \u003c- acct.load\u003c@AnyResource\u003e(from:FIND.BidStoragePath)\n\n\t\t\tacct.unlink(FIND.LeasePublicPath)\n\t\t\tdestroy \u003c- acct.load\u003c@AnyResource\u003e(from:FIND.LeaseStoragePath)\n\t}\n}",
            "removeRelatedAccount": "import RelatedAccounts from 0x097bafa4e0b48eef\n\n\ntransaction(name: String){\n\tprepare(account: AuthAccount) {\n\n\t\tlet cap = account.getCapability\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath)\n\t\tif !cap.check() {\n\t\t\tlet relatedAccounts \u003c- RelatedAccounts.createEmptyAccounts()\n\t\t\taccount.save(\u003c- relatedAccounts, to: RelatedAccounts.storagePath)\n\t\t\taccount.link\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath, target: RelatedAccounts.storagePath)\n\t\t}\n\n\t\tlet relatedAccounts =account.borrow\u003c\u0026RelatedAccounts.Accounts\u003e(from:RelatedAccounts.storagePath)!\n\t\trelatedAccounts.deleteAccount(name: name)\n\t}\n}",
            "renew": "import FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(acct: AuthAccount) {\n\n\t\tlet profileCap = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n\t\tlet price=FIND.calculateCost(name)\n\t\tif amount != price {\n\t\t\tpanic(\"expected renew cost is not the same as calculated renew cost\")\n\t\t}\n\t\tlet vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet payVault \u003c- vaultRef.withdraw(amount: price) as! @FUSD.Vault\n\n\t\tlet finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tlet finToken= finLeases.borrow(name)\n\t\tfinToken.extendLease(\u003c- payVault)\n\t}\n}",
            "sendCharity": "import NonFungibleToken from 0x1d7e57aa55817448\nimport CharityNFT from 0x097bafa4e0b48eef\n\n//mint an art and add it to a users collection\ntransaction(\n\tid: UInt64,\n\trecipient: Address\n) {\n\tlet receiverCap: Capability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e\n\tlet charityCollection: \u0026NonFungibleToken.Collection\n\n\tprepare(account: AuthAccount) {\n\t\tself.charityCollection =account.borrow\u003c\u0026NonFungibleToken.Collection\u003e(from: CharityNFT.CollectionStoragePath)!\n\t\tself.receiverCap= getAccount(recipient).getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t}\n\n\texecute {\n\t\tlet nft \u003c- self.charityCollection.withdraw(withdrawID: id)\n\t\tself.receiverCap.borrow()!.deposit(token: \u003c- nft)\n\t}\n}",
            "sendFT": "import NonFungibleToken from 0x1d7e57aa55817448\nimport FlowToken from 0x1654653399040a61\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport Profile from 0x097bafa4e0b48eef\nimport Sender from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport CharityNFT from 0x097bafa4e0b48eef\n\n\ntransaction(name: String, amount: UFix64, type: String) {\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t\tif !stdCap.check() {\n\t\t\taccount.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n\t\t\taccount.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\t\tif !charityCap.check() {\n\t\t\taccount.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t  let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\taccount.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profileName = account.address.toString()\n\n\t\t\tlet profile \u003c-Profile.createUser(name:profileName, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n\t\t\taccount.save(\u003c-profile, to: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tif account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n\t\t\taccount.save(\u003c- Sender.create(), to: Sender.storagePath)\n\t\t}\n\n\t\tlet token =account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n\n\n\t\tif type == \"fusd\" {\n\t\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\t\tlet vault \u003c- vaultRef.withdraw(amount: amount)\n\t\t\tFIND.depositWithTagAndMessage(to: name, message: \"\", tag: \"find\", vault: \u003c- vault, from: token)\n\t\t\treturn \n\t\t}\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount)\n\t\tFIND.depositWithTagAndMessage(to: name, message: \"\", tag: \"find\", vault: \u003c- vault, from: token)\n\t}\n\n}",
            "sendFlowWithMessage": "import NonFungibleToken from 0x1d7e57aa55817448\nimport FlowToken from 0x1654653399040a61\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport CharityNFT from 0x097bafa4e0b48eef\n\ntransaction(name: String, amount: UFix64, message:String) {\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t\tif !stdCap.check() {\n\t\t\taccount.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n\t\t\taccount.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\t\tif !charityCap.check() {\n\t\t\taccount.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\taccount.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profileName = account.address.toString()\n\n\t\t\tlet profile \u003c-Profile.createUser(name:profileName, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n\t\t\taccount.save(\u003c-profile, to: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tlet profile =account.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\n\n\t\tlet strLength = amount.toString().length\n\t\tlet amountString = amount.toString().slice(from: 0, upTo: strLength-6)\n\t\tprofile.verify(profile.getName().concat(\" sent \").concat(amountString).concat(\" Flow with message:\").concat(message))\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tFIND.deposit(to: name, from: \u003c- vaultRef.withdraw(amount: amount))\n\t}\n}",
            "sendFlowWithTagAndMessage": "import NonFungibleToken from 0x1d7e57aa55817448\nimport FlowToken from 0x1654653399040a61\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport Profile from 0x097bafa4e0b48eef\nimport Sender from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport CharityNFT from 0x097bafa4e0b48eef\n\ntransaction(name: String, amount: UFix64, message:String, tag: String) {\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t\tif !stdCap.check() {\n\t\t\taccount.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n\t\t\taccount.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\t\tif !charityCap.check() {\n\t\t\taccount.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t  let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\taccount.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profileName = account.address.toString()\n\n\t\t\tlet profile \u003c-Profile.createUser(name:profileName, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n\t\t\taccount.save(\u003c-profile, to: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tif account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n\t\t\taccount.save(\u003c- Sender.create(), to: Sender.storagePath)\n\t\t}\n\n\t\tlet token =account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount)\n\t\tFIND.depositWithTagAndMessage(to: name, message: message, tag: tag, vault: \u003c- vault, from: token)\n\t}\n\n}",
            "sendFusdWithTagAndMessage": "import NonFungibleToken from 0x1d7e57aa55817448\nimport FlowToken from 0x1654653399040a61\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport Profile from 0x097bafa4e0b48eef\nimport Sender from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport CharityNFT from 0x097bafa4e0b48eef\n\ntransaction(name: String, amount: UFix64, message:String, tag: String) {\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t\tif !stdCap.check() {\n\t\t\taccount.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n\t\t\taccount.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\t\tif !charityCap.check() {\n\t\t\taccount.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t  let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\taccount.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profileName = account.address.toString()\n\n\t\t\tlet profile \u003c-Profile.createUser(name:profileName, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n\t\t\taccount.save(\u003c-profile, to: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tif account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n\t\t\taccount.save(\u003c- Sender.create(), to: Sender.storagePath)\n\t\t}\n\n\t\tlet token =account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount)\n\t\tFIND.depositWithTagAndMessage(to: name, message: message, tag: tag, vault: \u003c- vault, from: token)\n\t}\n\n}",
            "sendFusdWithmessage": "import NonFungibleToken from 0x1d7e57aa55817448\nimport FlowToken from 0x1654653399040a61\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\nimport Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\nimport CharityNFT from 0x097bafa4e0b48eef\n\ntransaction(name: String, amount: UFix64, message:String) {\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t\tif !stdCap.check() {\n\t\t\taccount.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n\t\t\taccount.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\t\tif !charityCap.check() {\n\t\t\taccount.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t  let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\taccount.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profileName = account.address.toString()\n\n\t\t\tlet profile \u003c-Profile.createUser(name:profileName, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n\t\t\taccount.save(\u003c-profile, to: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tlet profile =account.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\n\t\tlet strLength = amount.toString().length\n\t\tlet amountString = amount.toString().slice(from: 0, upTo: strLength-6)\n\t\tprofile.verify(profile.getName().concat(\" sent \").concat(amountString).concat(\" FUSD with message:\").concat(message))\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tFIND.deposit(to: name, from: \u003c- vaultRef.withdraw(amount: amount))\n\n\t}\n\n}",
            "setMainName": "import Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\n\ntransaction(name: String) {\n\tprepare(acct: AuthAccount) {\n\n\t\tlet leaseCollectionOwner = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n\t\tif !leaseCollectionOwner.check() {\n\t\t\tpanic(\"Not a find user\")\n\t\t}\n\n\t\tif leaseCollectionOwner.borrow()!.getLease(name) == nil {\n\t\t\tpanic(\"You do not own this lease so you cannot set it as main name\")\n\t\t}\n\n\n\t\tlet profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\t\tprofile.setFindName(name)\n\t}\n}",
            "setPrivateMode": "import Profile from 0x097bafa4e0b48eef\nimport FIND from 0x097bafa4e0b48eef\n\ntransaction(mode: Bool) {\n\tprepare(acct: AuthAccount) {\n\t\tlet profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\t\tprofile.setPrivateMode(mode)\n\t}\n}",
            "setProfile": "import Profile from 0x097bafa4e0b48eef\n\n\ntransaction(avatar: String) {\n\tprepare(acct: AuthAccount) {\n\t\tlet profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\t\tprofile.setAvatar(avatar)\n\t}\n}",
            "setRelatedAccount": "import RelatedAccounts from 0x097bafa4e0b48eef\n\n\ntransaction(name: String, address: Address) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet cap = account.getCapability\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath)\n\t\tif !cap.check() {\n\t\t\tlet relatedAccounts \u003c- RelatedAccounts.createEmptyAccounts()\n\t\t\taccount.save(\u003c- relatedAccounts, to: RelatedAccounts.storagePath)\n\t\t\taccount.link\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath, target: RelatedAccounts.storagePath)\n\t\t}\n\n\t\tlet relatedAccounts =account.borrow\u003c\u0026RelatedAccounts.Accounts\u003e(from:RelatedAccounts.storagePath)!\n\t\trelatedAccounts.setFlowAccount(name: name, address: address)\n\t}\n}",
            "startAuction": "import FIND from 0x097bafa4e0b48eef\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.startAuction(name)\n\n\t}\n}",
            "storeCuratedCollections": "transaction(collections: {String :  [String]}) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet path=/storage/FindCuratedCollections\n\t\tlet publicPath=/public/FindCuratedCollections\n\n\t\tif account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n\t\t\t account.load\u003c{String: [String]}\u003e(from:path)\n\t\t}\n\t\taccount.save(collections, to: path)\n\n\t\tlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n\t\tif !link.check() {\n\t\t\taccount.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n\t\t}\n\t}\n}"
         }
      },
      "testnet": {
         "scripts": {
            "address_status": "import FIND from 0xa16ab1d0abde3625\nimport Profile from 0xa16ab1d0abde3625\nimport RelatedAccounts from 0xa16ab1d0abde3625\n\npub struct FINDReport{\n\tpub let profile:Profile.UserProfile?\n\tpub let bids: [FIND.BidInfo]\n\tpub let relatedAccounts: { String: Address}\n\tpub let leases: [FIND.LeaseInformation]\n\tpub let privateMode: Bool\n\n\tinit(profile: Profile.UserProfile?, relatedAccounts: {String: Address}, bids: [FIND.BidInfo], leases : [FIND.LeaseInformation], privateMode: Bool) {\n\t\tself.profile=profile\n\t\tself.bids=bids\n\t\tself.leases=leases\n\t\tself.relatedAccounts=relatedAccounts\n\t\tself.privateMode=privateMode\n\t}\n}\n\n//Check the status of a fin user\npub fun main(user: Address) : FINDReport{\n\n\tlet account=getAccount(user)\n\tlet bidCap = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\n\tlet leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\tlet profile=account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath).borrow()\n\treturn FINDReport(\n\t\tprofile: profile?.asProfile(),\n\t\trelatedAccounts: RelatedAccounts.findRelatedFlowAccounts(address:user),\n\t\tbids: bidCap.borrow()?.getBids() ?? [],\n\t\tleases: leaseCap.borrow()?.getLeaseInformation() ?? [],\n\t\tprivateMode: profile?.isPrivateModeEnabled() ?? false\n\t)\n\n}",
            "collections": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport CharityNFT from 0xa16ab1d0abde3625\n\n//mainnet\nimport Art from 0xd796ff17107bbff6\nimport Marketplace from 0xd796ff17107bbff6\nimport GooberXContract from 0x34f2bf4a80bb0f69\nimport Flovatar from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\nimport RareRooms_NFT from 0x329feb3ab062d289\nimport CNN_NFT from 0x329feb3ab062d289\nimport Canes_Vault_NFT from 0x329feb3ab062d289\nimport DGD_NFT from 0x329feb3ab062d289\nimport RaceDay_NFT from 0x329feb3ab062d289\nimport The_Next_Cartel_NFT from 0x329feb3ab062d289\nimport UFC_NFT from 0x329feb3ab062d289\nimport MotoGPCard from 0xa49cc0ee46c54bfb\nimport Gaia from 0x8b148183c28ff88f\nimport ChainmonstersRewards from 0x93615d25d14fa337\nimport Moments from 0xd4ad4740ee426334\nimport MatrixWorldFlowFestNFT from 0x2d2750f240198f91\nimport SturdyItems from 0x427ceada271aa0b1\nimport Evolution from 0xf4264ac8f3256818\nimport GeniaceNFT from 0xabda6627c70c7f52\nimport OneFootballCollectible from 0x6831760534292098\nimport CryptoPiggo from 0xd3df824bf81910a4\nimport GoatedGoatsVouchers from 0xdfc74d9d561374c0\nimport TraitPacksVouchers from 0xdfc74d9d561374c0\nimport HaikuNFT from 0xf61e40c19db2a9e2\nimport KlktnNFT from 0xabd6e80be7e9682c\nimport Mynft from 0xf6fcbef550d97aa5\n\n//xtingles\nimport Collectible from 0xf5b0eb433389ac3f\n\n\npub struct MetadataCollections {\n\n\tpub let items: {String : MetadataCollectionItem}\n\tpub let collections: {String : [String]}\n\tpub let curatedCollections: {String : [String]}\n\n\tinit(items: {String : MetadataCollectionItem}, collections: {String : [String]}, curatedCollections: {String: [String]}) {\n\t\tself.items=items\n\t\tself.collections=collections\n\t\tself.curatedCollections=curatedCollections\n\t}\n}\n\n\npub struct MetadataCollection{\n\tpub let type: String\n\tpub let items: [MetadataCollectionItem]\n\n\tinit(type:String, items: [MetadataCollectionItem]) {\n\t\tself.type=type\n\t\tself.items=items\n\t}\n}\n\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let listPrice: UFix64?\n\tpub let listToken: String?\n\tpub let contentType:String\n\tpub let rarity:String\n\n\n\tinit(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n\t\tself.id=id\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.listToken=listToken\n\t\tself.listPrice=listPrice\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\npub fun main(address: Address) : MetadataCollections? {\n\n\tlet resultMap : {String : MetadataCollectionItem} = {}\n\tlet account = getAccount(address)\n\tlet results : {String :  [String]}={}\n\n\tlet flovatarList= Flovatar.getFlovatars(address: address)\n\tlet flovatarMarketDetails = FlovatarMarketplace.getFlovatarSales(address: address)\n\tif flovatarList.length \u003e 0 || flovatarMarketDetails.length \u003e 0 {\n\t\tlet items: [String] = []\n\t\tfor flovatar in flovatarList  {\n\t\t\tvar name = flovatar.name\n\t\t\tif name == \"\" {\n\t\t\t\tname=\"Flovatar #\".concat(flovatar.id.toString())\n\t\t\t}\n\n\t\t\tvar rarity=\"common\"\n\t\t\tif flovatar.metadata.legendaryCount \u003e 0 {\n\t\t\t\trarity=\"legendary\"\n\t\t\t}else if flovatar.metadata.epicCount \u003e 0 {\n\t\t\t\trarity=\"epic\"\n\t\t\t}else if flovatar.metadata.rareCount \u003e 0 {\n\t\t\t\trarity=\"rare\"\n\t\t\t}\n\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: flovatar.id, \n\t\t\t\tname: name, \n\t\t\t\timage: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n\t\t\t\turl: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: rarity\n\t\t\t)\n\t\t\tlet itemId=\"Flovatar\".concat(flovatar.id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tfor flovatar in flovatarMarketDetails  {\n\t\t\tvar\tname=\"Flovatar #\".concat(flovatar.id.toString())\n\n\t\t\tvar rarity=\"common\"\n\t\t\tif flovatar.metadata.legendaryCount \u003e 0 {\n\t\t\t\trarity=\"legendary\"\n\t\t\t}else if flovatar.metadata.epicCount \u003e 0 {\n\t\t\t\trarity=\"epic\"\n\t\t\t}else if flovatar.metadata.rareCount \u003e 0 {\n\t\t\t\trarity=\"rare\"\n\t\t\t}\n\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: flovatar.id, \n\t\t\t\tname: name, \n\t\t\t\timage: \"https://flovatar.com/api/image/\".concat(flovatar.id.toString()),\n\t\t\t\turl: \"https://flovatar.com/flovatars/\".concat(flovatar.id.toString()).concat(\"/\"),\n\t\t\t\tlistPrice: flovatar.price,\n\t\t\t\tlistToken: \"Flow\",\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: rarity\n\t\t\t)\n\n\t\t\tlet itemId=\"Flovatar\".concat(flovatar.id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Flovatar\"] = items\n\t\t}\n\t}\n\n\tlet versusMarketplace = account.getCapability\u003c\u0026{Marketplace.SalePublic}\u003e(Marketplace.CollectionPublicPath)\n\tlet versusImageUrlPrefix = \"https://res.cloudinary.com/dxra4agvf/image/upload/c_fill,w_600/f_auto/maincache\"\n\tlet artList = Art.getArt(address: address)\n\tif artList.length \u003e 0 || versusMarketplace.check() {\n\t\tlet items: [String] = []\n\t\tfor art in artList {\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: art.id, \n\t\t\t\tname: art.metadata.name.concat(\" edition \").concat(art.metadata.edition.toString()).concat(\"/\").concat(art.metadata.maxEdition.toString()).concat(\" by \").concat(art.metadata.artist),  \n\t\t\t\timage: versusImageUrlPrefix.concat(art.cacheKey), \n\t\t\t\turl: \"https://www.versus.auction/piece/\".concat(address.toString()).concat(\"/\").concat(art.id.toString()).concat(\"/\"),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"Versus\".concat(art.id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\t\t}\n\t\tif versusMarketplace.check() {\n\t\t\tlet versusMarket = versusMarketplace.borrow()!.listSaleItems()\n\t\t\tfor saleItem in versusMarket {\n\t\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\t\tid: saleItem.id, \n\t\t\t\t\tname: saleItem.art.name.concat(\" edition \").concat(saleItem.art.edition.toString()).concat(\"/\").concat(saleItem.art.maxEdition.toString()).concat(\" by \").concat(saleItem.art.artist),\n\t\t\t\t\timage: versusImageUrlPrefix.concat(saleItem.cacheKey), \n\t\t\t\t\turl: \"https://www.versus.auction/listing/\".concat(saleItem.id.toString()).concat(\"/\"),\n\t\t\t\t\tlistPrice: saleItem.price,\n\t\t\t\t\tlistToken: \"Flow\",\n\t\t\t\t\tcontentType: \"image\",\n\t\t\t\t\trarity: \"\"\n\t\t\t\t)\n\n\t\t\t\tlet itemId=\"Versus\".concat(saleItem.id.toString())\n\t\t\t\titems.append(itemId)\n\t\t\t\tresultMap[itemId] = item\n\t\t\t}\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"Versus\"]= items\n\t\t}\n\t}\n\n\n\n\n\tlet goobersCap = account.getCapability\u003c\u0026GooberXContract.Collection{NonFungibleToken.CollectionPublic, GooberXContract.GooberCollectionPublic}\u003e(GooberXContract.CollectionPublicPath)\n\tif goobersCap.check() {\n\t\tlet items: [String] = []\n\t\tlet goobers = goobersCap.borrow()!.listUsersGoobers()\n\t\tfor id in goobers.keys {\n\t\t\tlet goober = goobers[id]!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"Goober #\".concat(id.toString()),\n\t\t\t\timage: goober.uri,\n\t\t\t\turl: \"https://partymansion.io/gooberz/\".concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"Gooberz\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"Gooberz\"] = items\n\t\t}\n\t}\n\n\tlet rareRoomCap = account.getCapability\u003c\u0026RareRooms_NFT.Collection{RareRooms_NFT.RareRooms_NFTCollectionPublic}\u003e(RareRooms_NFT.CollectionPublicPath)\n\tif rareRoomCap.check() {\n\t\tlet collection = rareRoomCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowRareRooms_NFT(id: id)!\n\t\t\tlet metadata = RareRooms_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: metadata[\"preview\"]!,\n\t\t\t\turl: \"https://rarerooms.io/tokens/\".concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"RareRooms\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"RareRooms\"] = items\n\t\t}\n\t}\n\n\tlet cnnCap = account.getCapability\u003c\u0026CNN_NFT.Collection{CNN_NFT.CNN_NFTCollectionPublic}\u003e(CNN_NFT.CollectionPublicPath)\n\tif cnnCap.check() {\n\t\tlet collection = cnnCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowCNN_NFT(id: id)!\n\t\t\tlet metadata = CNN_NFT.getSetMetadata(setId: nft.setId)!\n\n\t\t  var image= metadata[\"preview\"]!\n\t\t\tvar contentType=\"image\"\n\t\t\t/*\n\t\t\tif metadata[\"image_file_type\"]! == \"mp4\" {\n\t\t\t\timage=metadata[\"image\"]!\n\t\t\t\tcontentType=\"video\"\n\t\t\t}\n\t\t\t*/\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: image,\n\t\t\t\turl: \"http://vault.cnn.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"CNN\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"CNN\"] = items\n\t\t}\n\t}\n\n\tlet canesVaultCap = account.getCapability\u003c\u0026Canes_Vault_NFT.Collection{Canes_Vault_NFT.Canes_Vault_NFTCollectionPublic}\u003e(Canes_Vault_NFT.CollectionPublicPath)\n\tif canesVaultCap.check() {\n\t\tlet collection = canesVaultCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowCanes_Vault_NFT(id: id)!\n\t\t\tlet metadata = Canes_Vault_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tvar image= metadata[\"preview\"]!\n\t\t\tvar contentType=\"image\"\n\t\t\t/*\n\t\t\tif metadata[\"image_file_type\"]! == \"mp4\" {\n\t\t\t\timage=metadata[\"image\"]!\n\t\t\t\tcontentType=\"video\"\n\t\t\t}\n\t\t\t*/\n\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: image,\n\t\t\t\turl: \"https://canesvault.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"Canes_Vault_NFT\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Canes_Vault_NFT\"] = items\n\t\t}\n\t}\n\n\tlet dgdCap = account.getCapability\u003c\u0026DGD_NFT.Collection{DGD_NFT.DGD_NFTCollectionPublic}\u003e(DGD_NFT.CollectionPublicPath)\n\tif dgdCap.check() {\n\t\tlet collection = dgdCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowDGD_NFT(id: id)!\n\t\t\tlet metadata = DGD_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tvar image= metadata[\"preview\"]!\n\t\t\tvar contentType=\"image\"\n\t\t\t/*\n\t\t\tif metadata[\"image_file_type\"]! == \"mp4\" {\n\t\t\t\timage=metadata[\"image\"]!\n\t\t\t\tcontentType=\"video\"\n\t\t\t}\n\t\t\t*/\n\n\t\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: image,\n\t\t\t\turl: \"https://www.theplayerslounge.io/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"DGD_NFT\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"DGD_NFT\"] = items\n\t\t}\n\t}\n\n\tlet raceDayCap = account.getCapability\u003c\u0026RaceDay_NFT.Collection{RaceDay_NFT.RaceDay_NFTCollectionPublic}\u003e(RaceDay_NFT.CollectionPublicPath)\n\tif raceDayCap.check() {\n\t\tlet collection = raceDayCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowRaceDay_NFT(id: id)!\n\t\t\tlet metadata = RaceDay_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tvar image= metadata[\"preview\"]!\n\t\t\tvar contentType=\"image\"\n\t\t\t/*\n\t\t\tif metadata[\"image_file_type\"]! == \"mp4\" {\n\t\t\t\timage=metadata[\"image\"]!\n\t\t\t\tcontentType=\"video\"\n\t\t\t}\n\t\t\t*/\n\n\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: image, \n\t\t\t\turl: \"https://www.racedaynft.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"RaceDay_NFT\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"RaceDay_NFT\"] = items\n\t\t}\n\t}\n\n\tlet nextCartelCap = account.getCapability\u003c\u0026The_Next_Cartel_NFT.Collection{The_Next_Cartel_NFT.The_Next_Cartel_NFTCollectionPublic}\u003e(The_Next_Cartel_NFT.CollectionPublicPath)\n\tif nextCartelCap.check() {\n\t\tlet collection = nextCartelCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowThe_Next_Cartel_NFT(id: id)!\n\t\t\tlet metadata = The_Next_Cartel_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tvar image= metadata[\"preview\"]!\n\t\t\tvar contentType=\"image\"\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\t// we use \"preview\" and not \"image\" because of potential .glg and .mp4 file types\n\t\t\t\timage: image,\n\t\t\t\turl: \"https://thenextcartel.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"The_Next_Cartel_NFT\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"The_Next_Cartel_NFT\"] = items\n\t\t}\n\t}\n\n\tlet ufcCap = account.getCapability\u003c\u0026UFC_NFT.Collection{UFC_NFT.UFC_NFTCollectionPublic}\u003e(UFC_NFT.CollectionPublicPath)\n\tif ufcCap.check() {\n\t\tlet collection = ufcCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowUFC_NFT(id: id)!\n\t\t\tlet metadata = UFC_NFT.getSetMetadata(setId: nft.setId)!\n\t\t\tvar image= metadata[\"image\"]!\n\t\t\tvar contentType=\"video\"\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: image,\n\t\t\t\turl: \"https://www.ufcstrike.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: contentType,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"UFC\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"UFC\"] = items\n\t\t}\n\t}\n\n\tlet motoGPCollection = account.getCapability\u003c\u0026MotoGPCard.Collection{MotoGPCard.ICardCollectionPublic}\u003e(/public/motogpCardCollection)\n\tif motoGPCollection.check() {\n\t\tlet motoGPNfts = motoGPCollection.borrow()!.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in motoGPNfts {\n\t\t\tlet nft = motoGPCollection.borrow()!.borrowCard(id: id)!\n\t\t\tlet metadata = nft.getCardMetadata()!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: metadata.imageUrl,\n\t\t\t\turl: \"https://motogp-ignition.com/nft/card/\".concat(id.toString()).concat(\"?owner=\").concat(address.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\n\t\t\tlet itemId=\"MotoGP\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"MotoGP\"] = items\n\t\t}\n\t}\n\n\tlet gaiaCollection = account.getCapability\u003c\u0026{Gaia.CollectionPublic}\u003e(Gaia.CollectionPublicPath)\n\tif gaiaCollection.check() {\n\n\t\tlet gaiaNfts = gaiaCollection.borrow()!.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in gaiaNfts {\n\t\t\tlet nft = gaiaCollection.borrow()!.borrowGaiaNFT(id: id)!\n\t\t\tlet metadata = Gaia.getTemplateMetaData(templateID: nft.data.templateID)!\n\n\n\t\t\t//For ballerz we can do this...\n\t\t\tvar url=\"http://ongaia.com/ballerz/\".concat(metadata[\"id\"]!)\n\t\t\tvar name=metadata[\"title\"]!\n\n\t\t\tif let seriesFullName=metadata[\"series\"] {\n\n\t\t\t\tif seriesFullName==\"Shareef O\\u{2019}Neal - Basketball\" {\n\t\t\t\t\t//If the series is basketball with shareef we can do this\n\t\t\t\t\turl=\"http://ongaia.com/sharef/\".concat(id.toString())\n\t\t\t\t\tname=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n\t\t\t\t}else if seriesFullName==\"Bryson DeChambeau - Vegas, Baby!\" {\n\t\t\t\t\t//For golf there is yet another way\n\t\t\t\t\turl=\"http://ongaia.com/bryson/\".concat(nft.data.mintNumber.toString())\n\t\t\t\t\tname=metadata[\"title\"]!.concat(\" #\").concat(nft.data.mintNumber.toString())\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tlet item= MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: name,\n\t\t\t\timage: metadata[\"img\"]!,\n\t\t\t\turl: url,\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"Gaia\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Gaia\"] = items\n\t\t}\n\t}\n\n\t/*\n\tlet chamonsterSeasonTable :  {UInt32: String} = {0 : \"kickstarter\", 1 : \"alpha\", 2 : \"genesis\", 4 : \"flowfest2021\" , 3: \"closedbeta\" }\n\n\tlet chainmonstersRewardsCollection = account.getCapability\u003c\u0026{ChainmonstersRewards.ChainmonstersRewardCollectionPublic}\u003e(/public/ChainmonstersRewardCollection)\n\tif chainmonstersRewardsCollection.check() {\n\t\tlet nfts = chainmonstersRewardsCollection.borrow()!.getIDs()\n\t\tlet items: [MetadataCollectionItem] = []\n\t\tfor id in nfts {\n\t\t\tlet nft = chainmonstersRewardsCollection.borrow()!.borrowReward(id: id)!\n\t\t\tlet rewardID = nft.data.rewardID\n\t\t\t// Other interesting metadata available are:\n\t\t\t// \t\t- serialNumber: nft.data.serialNumber\n\t\t\t// \t\t- totalMinted: ChainmonstersRewards.getNumRewardsMinted(rewardID: nft.data.rewardID)!\n\t\t\tlet season = ChainmonstersRewards.getRewardSeason(rewardID:nft.data.rewardID)!\n\n\t\t\tvar seasonName = chamonsterSeasonTable[season] ?? \"unknown\".concat(season.toString())\n\n\t\t\tif season == 3 \u0026\u0026 rewardID \u003c 45 {\n\t\t\t\tseasonName = \"flowfest2021\"\n\t\t\t}\n\t\t\titems.append(MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: ChainmonstersRewards.getRewardMetaData(rewardID: nft.data.rewardID)!,\n\t\t\t\timage: \"https://chainmonsters.com/images/rewards/\".concat(seasonName).concat(\"/\").concat(rewardID.toString()).concat(\".png\"),\n\t\t\t\turl: \"https://chainmonsters.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\"\n\t\t\t))\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"ChainmonstersRewards\"] = MetadataCollection(type: Type\u003c@ChainmonstersRewards.Collection\u003e().identifier, items: items)\n\t\t}\n\t}\n\t*/\n\n\tlet jambbCap = account.getCapability\u003c\u0026Moments.Collection{Moments.CollectionPublic}\u003e(Moments.CollectionPublicPath)\n\tif jambbCap.check() {\n\t\tlet nfts = jambbCap.borrow()!.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in nfts {\n\t\t\tlet nft = jambbCap.borrow()!.borrowMoment(id: id)!\n\t\t\tlet metadata=nft.getMetadata()\n\t\t\tlet item  =MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.contentName,\n\t\t\t\timage: \"ipfs://\".concat(metadata.videoHash),\n\t\t\t\turl: \"http://jambb.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"Jambb\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Jambb\"] = items\n\t\t}\n\t}\n\n\tlet mw = MatrixWorldFlowFestNFT.getNft(address:address)\n\tif mw.length \u003e 0 {\n\t\tlet items: [String] = []\n\t\tfor nft in mw {\n\t\t\tlet metadata=nft.metadata\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: nft.id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: metadata.animationUrl,\n\t\t\t\turl: \"https://matrixworld.org/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"MatrixWorldFlowFest\".concat(nft.id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"MatrixWorld\"] = items\n\t\t}\n\t}\n\n\tlet sturdyCollectionCap = account\n\t.getCapability\u003c\u0026SturdyItems.Collection{SturdyItems.SturdyItemsCollectionPublic}\u003e(SturdyItems.CollectionPublicPath)\n\tif sturdyCollectionCap.check() {\n\t\tlet sturdyNfts = sturdyCollectionCap.borrow()!.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in sturdyNfts {\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = sturdyCollectionCap.borrow()!.borrowSturdyItem(id: id)!\n\t\t\t// the only thing we can play with is the nft title which is for example:\n\t\t\t// \t- \"HOODLUM#10\"\n\t\t\t// \t- \"HOLIDAY MYSTERY BADGE 2021\"\n\t\t\t//  - \"EXCALIBUR\"\n\t\t\tlet isHoodlum = nft.tokenTitle.slice(from: 0, upTo: 7) == \"HOODLUM\"\n\t\t\tif isHoodlum {\n\t\t\t\t// the hoodlum id is needed to retrieve the image but is not in the nft\n\t\t\t\tlet hoodlumId = nft.tokenTitle.slice(from: 8, upTo: nft.tokenTitle.length)\n\t\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\t\tid: id,\n\t\t\t\t\tname: nft.tokenTitle,\n\t\t\t\t\timage: \"https://hoodlumsnft.com/_next/image?url=%2Fthumbs%2FsomeHoodlum_\".concat(hoodlumId).concat(\".png\u0026w=1920\u0026q=75\"),\n\t\t\t\t\turl: \"https://hoodlumsnft.com/\",\n\t\t\t\t\tlistPrice:nil,\n\t\t\t\t\tlistToken:nil,\n\t\t\t\t\tcontentType:\"image\",\n\t\t\t\t\trarity: \"\"\n\t\t\t\t)\n\t\t\t\tlet itemId=\"Hoodlums\".concat(id.toString())\n\t\t\t\titems.append(itemId)\n\t\t\t\tresultMap[itemId] = item\n\t\t\t}\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"Hoodlums\"] = items\n\t\t}\n\t}\n\n\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\tif charityCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = charityCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowCharity(id: id)!\n\t\t\tlet metadata = nft.getMetadata()\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: metadata[\"thumbnail\"]!,\n\t\t\t\turl: metadata[\"originUrl\"]!,\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType:\"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"Charity\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"Find\"] = items\n\t\t}\n\t}\n\n\tlet evolutionCap=account.getCapability\u003c\u0026{Evolution.EvolutionCollectionPublic}\u003e(/public/f4264ac8f3256818_Evolution_Collection)\n\tif evolutionCap.check() {\n\t\tlet evolution=evolutionCap.borrow()!\n\t\tlet nfts = evolution.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in nfts{\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = evolution.borrowCollectible(id: id)!\n\t\t\tlet metadata = Evolution.getItemMetadata(itemId: nft.data.itemId)!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"Title\"]!.concat(\" #\").concat(nft.data.serialNumber.toString()),\n\t\t\t\timage: \"https://storage.viv3.com/0xf4264ac8f3256818/mv/\".concat(nft.data.itemId.toString()),\n\t\t\t\turl: \"https://www.evolution-collect.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType:\"video\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"Evolution\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Evolution\"] = items\n\t\t}\n\t}\n\n\n\tlet geniaceCap = account.getCapability\u003c\u0026GeniaceNFT.Collection{NonFungibleToken.CollectionPublic, GeniaceNFT.GeniaceNFTCollectionPublic}\u003e(GeniaceNFT.CollectionPublicPath)\n\tif geniaceCap.check() {\n\t\tlet geniace=geniaceCap.borrow()!\n\t\tlet nfts = geniace.getIDs()\n\t\tlet items: [String] = []\n\t\tfor id in nfts{\n\t\t\t// the metadata is a JSON stored on IPFS at the address nft.tokenURI\n\t\t\tlet nft = geniace.borrowGeniaceNFT(id: id)!\n\t\t\tlet metadata = nft.metadata\n\t\t\tvar rarity=\"\"\n\t\t\tif metadata.rarity == GeniaceNFT.Rarity.Collectible {\n\t\t\t\trarity=\"Collectible\"\n\t\t\t}else if metadata.rarity == GeniaceNFT.Rarity.Rare {\n\t\t\t\trarity=\"Rare\"\n\t\t\t}else if metadata.rarity == GeniaceNFT.Rarity.UltraRare {\n\t\t\t\trarity=\"UltraRare\"\n\t\t\t}\n\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: metadata.imageUrl,\n\t\t\t\turl: \"https://www.geniace.com/product/\".concat(metadata.name),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: metadata.data[\"mimetype\"]!,\n\t\t\t\trarity: rarity,\n\t\t\t)\n\n\t\t\tlet itemId=\"Geniace\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"Geniace\"] = items\n\t\t}\n\t}\n\n\t// https://flow-view-source.com/mainnet/account/0x6831760534292098/contract/OneFootballCollectible\n\tlet oneFootballCollectibleCap = account.getCapability\u003c\u0026OneFootballCollectible.Collection{OneFootballCollectible.OneFootballCollectibleCollectionPublic}\u003e(OneFootballCollectible.CollectionPublicPath)\n\tif oneFootballCollectibleCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = oneFootballCollectibleCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowOneFootballCollectible(id: id)!\n\t\t\tlet metadata = nft.getTemplate()!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: \"ipfs://\".concat(metadata.media),\n\t\t\t\turl: \"https://xmas.onefootball.com/\".concat(account.address.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\tlet itemId=\"OneFootballCollectible\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"OneFootballCollectible\"] = items\n\t\t}\n\t}\n\n\n\tlet cryptoPiggoCap = account.getCapability\u003c\u0026{CryptoPiggo.CryptoPiggoCollectionPublic}\u003e(CryptoPiggo.CollectionPublicPath)\n\tif cryptoPiggoCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = cryptoPiggoCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowItem(id: id)!\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"CryptoPiggo #\".concat(id.toString()),\n\t\t\t\timage: \"https://s3.us-west-2.amazonaws.com/crypto-piggo.nft/piggo-\".concat(id.toString()).concat(\".png\"),\n\t\t\t\turl: \"https://rareworx.com/piggo/details/\".concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\tlet itemId=\"CryptoPiggo\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"CryptoPiggo\"] = items\n\t\t}\n\t}\n\n\tlet xtingles = Collectible.getCollectibleDatas(address:address) \n\tif xtingles.length \u003e 0 {\n\t\tlet items: [String] = []\n\t\tfor nft in xtingles {\n\n\t\t\tvar image=nft.metadata.link\n\n\t\t\tlet prefix=\"https://\"\n\t\t\tif image.slice(from:0, upTo:prefix.length) != prefix {\n\t\t\t\timage=\"ipfs://\".concat(image)\n\t\t\t}\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: nft.id,\n\t\t\t\tname: nft.metadata.name.concat(\" #\").concat(nft.metadata.edition.toString()),\n\t\t\t\timage: image,\n\t\t\t\turl: \"http://xtingles.com\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"video\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\tlet itemId=\"Xtingles\".concat(nft.id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\n\n\t\t}\n\t\tif items.length != 0 {\n\t\t\tresults[\"Xtingles\"] = items\n\t\t}\n\t}\n\n\tlet goatsCap = account.getCapability\u003c\u0026{GoatedGoatsVouchers.GoatsVoucherCollectionPublic}\u003e(GoatedGoatsVouchers.CollectionPublicPath)\n\tvar goats : [String]=[]\n\tif goatsCap.check() {\n\t\tlet goatsImageUrl= GoatedGoatsVouchers.getCollectionMetadata()[\"mediaURL\"]!\n\t\tlet collection = goatsCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"Goated Goat Base Goat Voucher #\".concat(id.toString()),\n\t\t\t\timage: goatsImageUrl, \n\t\t\t\turl: \"https://goatedgoats.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\tlet itemId=\"GoatedGoatsVoucher\".concat(id.toString())\n\t\t\tgoats.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\n\n\tlet goatsTraitCap = account.getCapability\u003c\u0026{TraitPacksVouchers.PackVoucherCollectionPublic}\u003e(TraitPacksVouchers.CollectionPublicPath)\n\tif goatsTraitCap.check() {\n\t\tlet goatsImageUrl= TraitPacksVouchers.getCollectionMetadata()[\"mediaURL\"]!\n\t\tlet collection = goatsTraitCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"Goated Goat Trait Pack Voucher #\".concat(id.toString()),\n\t\t\t\timage: goatsImageUrl, \n\t\t\t\turl: \"https://goatedgoats.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\n\t\t\t)\n\t\t\tlet itemId=\"GoatedGoatsTraitVoucher\".concat(id.toString())\n\t\t\tgoats.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\t}\n\n\tif goats.length != 0 {\n\t\t\tresults[\"GoatedGoats\"] = goats\n\t}\n\n  let bitkuCap = account.getCapability\u003c\u0026{HaikuNFT.HaikuCollectionPublic}\u003e(HaikuNFT.HaikuCollectionPublicPath)\n\tif bitkuCap.check() {\n\t\tlet collection = bitkuCap.borrow()!\n\t\tlet items: [String] = []\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowHaiku(id: id)!\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"Bitku #\".concat(id.toString()),\n\t\t\t\timage: nft.text,\n\t\t\t\turl: \"https://bitku.art/#\".concat(address.toString()).concat(\"/\").concat(id.toString()),\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"text\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\tlet itemId=\"BitKu\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"BitKu\"] = items\n\t\t}\n\t}\n\tlet klktnCap = account.getCapability\u003c\u0026{KlktnNFT.KlktnNFTCollectionPublic}\u003e(KlktnNFT.CollectionPublicPath)\n\tif klktnCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = klktnCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowKlktnNFT(id: id)!\n\n\t\t\tlet metadata=nft.getNFTMetadata()\n\t\t\t/*\n\n\t\t\tResult: {\"uri\": \"ipfs://bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym\", \"name\": \"Kevin Woo - What is KLKTN?\", \"mimeType\": \"video/mp4\", \"media\": \"https://ipfs.io/ipfs/bafybeifsiousmtmcruuelgyiku3xa5hmw7ylsyqfdvpjsea7r4xa74bhym/fb91ad34d61dde04f02ad240f0ca924902d8b4a3da25daaf0bb1ed769977848c.mp4\", \"description\": \"K-pop sensation Kevin Woo has partnered up with KLKTN to enhance his artist to fan interactions and experiences within his fandom. Join our chat to learn more: https://discord.gg/UJxb4erfUw\"}\n\n\t\t\t*/\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata[\"name\"]!,\n\t\t\t\timage: metadata[\"media\"]!,\n\t\t\t\turl: \"https://klktn.com/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"video\", //metadata[\"mimeType\"]!,\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t    let itemId=\"KLKTN\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"KLKTN\"] = items\n\t\t}\n\t}\n\n\tlet mynftCap = account.getCapability\u003c\u0026{Mynft.MynftCollectionPublic}\u003e(Mynft.CollectionPublicPath)\n\tif mynftCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection = mynftCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowArt(id: id)!\n\t\t\tlet metadata=nft.metadata\n\n\t\t\tvar image= metadata.ipfsLink\n\t\t\tif image == \"\" {\n\t\t\t\timage=\"https://arweave.net/\".concat(metadata.arLink)\n\t\t\t}\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: image,\n\t\t\t\turl: \"http://mynft.io\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n      let itemId=\"mynft\".concat(id.toString())\n\t\t\titems.append(itemId)\n\t\t\tresultMap[itemId] = item\n\t\t}\n\n\n\t\tif items.length != 0 {\n\t\t\tresults[\"mynft\"] = items\n\t\t}\n\t}\n\n\tif results.keys.length == 0 {\n\t\treturn nil\n\t}\n\n\tlet publicPath=/public/FindCuratedCollections\n\tlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n\tvar curatedCollections : {String: [String]} = {}\n\tif link.check() {\n\t\tlet curated = link.borrow()!\n\t\tfor curatedKey in curated.keys {\n\t\t\tcuratedCollections[curatedKey] = curated[curatedKey]!\n\t\t}\n\t}\n\n\treturn MetadataCollections(items: resultMap, collections:results, curatedCollections: curatedCollections)\n}",
            "curatedCollections": "pub fun main(address: Address) : \u0026{String: [String]}? {\n\tlet account=getAccount(address)\n\tlet publicPath=/public/FindCuratedCollections\n\tlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n\tif link.check() {\n\t\treturn link.borrow()\n\t}\n\treturn nil\n}",
            "flobits": "import FlovatarComponent from 0x921ea449dffec68a\nimport FlovatarMarketplace from  0x921ea449dffec68a\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let listPrice: UFix64?\n\tpub let listToken: String?\n\tpub let contentType:String\n\tpub let rarity:String\n\n\n\tinit(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n\t\tself.id=id\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.listToken=listToken\n\t\tself.listPrice=listPrice\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\npub fun main(addr: Address) : [MetadataCollectionItem] {\n\n\tlet flovatarComponents= FlovatarComponent.getComponents(address: addr)\n\n\tlet templateNumbers : {UInt64: UInt64} = {}\n\tlet templateData : {UInt64: FlovatarComponent.ComponentData} = {}\n\tfor flovatar in flovatarComponents {\n\n\t\tlet templateId= flovatar.templateId\n\t\tvar number:UInt64=1\n\t\tif templateNumbers[templateId] == nil {\n\t\t\ttemplateNumbers[templateId] = (1 as UInt64)\n\t\t\ttemplateData[templateId]=flovatar\n\t\t} else {\n\t\t\ttemplateNumbers[templateId] = templateNumbers[templateId]! + 1\n\t\t}\n\t}\n\n\n\tlet flovatarMarketComponents=FlovatarMarketplace.getFlovatarComponentSales(address:addr)\n\n\tfor flovatar in flovatarMarketComponents {\n\n\t\tlet templateId= flovatar.metadata.templateId\n\t\t\tvar number:UInt64=1\n\t\t\tif templateNumbers[templateId] == nil {\n\t\t\t\ttemplateNumbers[templateId] = (1 as UInt64)\n\t\t\t\ttemplateData[templateId]=FlovatarComponent.getComponent(address:addr, componentId: flovatar.id)!\n\t\t\t} else {\n\t\t\t\ttemplateNumbers[templateId] = templateNumbers[templateId]! + 1\n\t\t\t}\n\t}\n\n\n\tlet flovatarC : [MetadataCollectionItem] = []\n\tfor templateId in templateData.keys {\n\t\tlet template=templateData[templateId]!\n\n\n\t\tvar name=template.name\n\n\t\tif templateId == 75 || templateId==74 || templateId == 73 {\n\t\t\tname=name.concat(\" Booster\")\n\t\t}\n\n\t\tif templateNumbers[templateId]! \u003e 1 {\n\t\t\tname=name.concat(\" x \").concat(templateNumbers[templateId]!.toString())\n\t\t} \n\n\t\tlet item=MetadataCollectionItem(\n\t\t\tid: template.id, \n\t\t\tname: name, \n\t\t\timage: \"https://flovatar.com/api/image/template/\".concat(templateId.toString()),\n\t\t\turl: \"https://flovatar.com\",\n\t\t\tlistPrice: nil,\n\t\t\tlistToken: nil,\n\t\t\tcontentType: \"image\",\n\t\t\trarity: template.rarity\n\t\t)\n\n\t\tflovatarC.append(item)\n\t}\n\n\treturn flovatarC\n\n}",
            "gg": "import GoatedGoatsVouchers from 0xdfc74d9d561374c0\n\npub fun main(addr: Address) : {String:String} {\n\n\tlet account=getAccount(addr)\n\n\tlet goatedGoatsCap = account.getCapability\u003c\u0026{GoatedGoatsVouchers.GoatsVoucherCollectionPublic}\u003e(GoatedGoatsVouchers.CollectionPublicPath)\n\tif goatedGoatsCap.check() {\n\t\tlet items: [String] = []\n\t\tlet collection=goatedGoatsCap.borrow()!\n\t\tlet goats = collection.getIDs()\n\t\tfor id in goats {\n\n\t\t\tlet i = collection.borrowVoucher(id:id)!\n\t\t\tlet m = i.getMetadata()\n\t\t\tm[\"id\"] = id.toString()\n\t\t\treturn m\n\t\t}\n\t}\n\treturn {}\n}",
            "hasCharity": "import CharityNFT from 0xa16ab1d0abde3625\n\n//Check the status of a fin user\npub fun main(user: Address) : Bool {\n\tlet account=getAccount(user)\n\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\treturn charityCap.check()\n}",
            "isFindUser": "import Profile from 0xa16ab1d0abde3625\nimport FIND from 0xa16ab1d0abde3625\n\n//Check the status of a fin user\npub fun main(user: Address) : Bool {\n\n\tlet account=getAccount(user)\n\tlet leaseCap=account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\tlet profileCap=account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n\treturn leaseCap.check() \u0026\u0026 profileCap.check()\n\n}",
            "matrixworld": "import MatrixWorldVoucher from 0x0d77ec47bbad8ef6\n\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let listPrice: UFix64?\n\tpub let listToken: String?\n\tpub let contentType:String\n\tpub let rarity:String\n\n\n\tinit(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n\t\tself.id=id\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.listToken=listToken\n\t\tself.listPrice=listPrice\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\npub fun main(address: Address) : [MatrixWorldVoucher.Metadata]{\n\n\n\tlet items: [MatrixWorldVoucher.Metadata] = []\n\tlet mw = MatrixWorldVoucher.getNft(address:address)\n\tif mw.length \u003e 0 {\n\t\tfor nft in mw {\n\t\t\titems.append(nft.metadata)\n\t\t\t/*\n\t\t\tlet metadata=nft.metadata\n\t\t\tlet item=MetadataCollectionItem(\n\t\t\t\tid: nft.id,\n\t\t\t\tname: metadata.name,\n\t\t\t\timage: metadata.animationUrl,\n\t\t\t\turl: \"https://matrixworld.org/\",\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"image\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\t\t\titems.append(item)\n\t\t}\n\t\t*/\n\t}\n\n\t}\n\treturn items\n}",
            "name": "import FIND from 0xa16ab1d0abde3625\n\npub fun main(address: Address) : String?{\n\treturn FIND.reverseLookup(address)\n}",
            "nameCrawler": "import FIND from 0xa16ab1d0abde3625\nimport Profile from 0xa16ab1d0abde3625\n\npub fun main(names: [String]) : [FIND.LeaseInformation]{\n\tlet items : [FIND.LeaseInformation]=[]\n\tfor name in names {\n\t\tlet nameStatus=FIND.status(name)\n\t\tif let address=nameStatus.owner {\n\t\t\tlet account=getAccount(address)\n\t\t\tlet leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\t\titems.append(leaseCap.borrow()!.getLease(name)!)\n\t\t} else {\n\t\t\t//free name now\n\t\t\tcontinue\n\t\t}\n\t}\n\treturn items\n}",
            "name_status": "import FIND from 0xa16ab1d0abde3625\nimport Profile from 0xa16ab1d0abde3625\n\npub struct FINDNameReport{\n\tpub let profile:Profile.UserProfile?\n\tpub let lease: FIND.LeaseInformation?\n\tpub let status: String\n\tpub let cost: UFix64\n\tpub let leases: [FIND.LeaseInformation]\n\n\tinit(status: String, profile: Profile.UserProfile?, lease : FIND.LeaseInformation?,  cost: UFix64, leases: [FIND.LeaseInformation]) {\n\t\tself.status=status\n\t\tself.profile=profile\n\t\tself.lease=lease\n\t\tself.cost=cost\n\t\tself.leases=leases\n\t}\n}\n\n//Check the status of a fin user\npub fun main(name: String) : FINDNameReport{\n\n\tlet status=FIND.status(name)\n\tlet cost=FIND.calculateCost(name)\n\tif let address=status.owner {\n\t\tlet account=getAccount(address)\n\t\tlet leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n\t\tlet profile= account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath).borrow()\n\t\tvar lease:FIND.LeaseInformation?=nil\n\t\tif leaseCap.check() {\n\t\t\tlease=leaseCap.borrow()!.getLease(name)\n\t\t}\n\t\treturn FINDNameReport(\n\t\t\tstatus: lease?.status ?? \"taken\",\n\t\t\tprofile: profile?.asProfile(),\n\t\t\tlease: lease,\n\t\t\tcost:  cost,\n\t\t\tleases: leaseCap.borrow()?.getLeaseInformation() ?? []\n\t\t)\n\n\t}\n\n\tvar statusValue= \"FREE\"\n\tif  status.status == FIND.LeaseStatus.TAKEN {\n\t\tstatusValue=\"NO_PROFILE\"\n\t}\n\treturn FINDNameReport(\n\t\tstatus: statusValue,\n\t\tprofile: nil, \n\t\tlease: nil,\n\t\tcost: cost,\n\t\tleases: [],\n\t)\n\n}",
            "names": "import FIND from 0xa16ab1d0abde3625\n\npub fun main(address: [Address]) : { Address:String}{\n\n\tlet items : {Address:String} = {}\n\tfor a in address {\n\t\tif let name= FIND.reverseLookup(a) {\n\t\t\titems[a]=name\n\t\t}\n\t}\n\treturn items\n}",
            "profile": "import Profile from 0xa16ab1d0abde3625\n\n//Check the status of a fin user\npub fun main(address: Address) :  Profile.UserProfile? {\n\treturn getAccount(address)\n\t\t.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\t.borrow()?.asProfile()\n}",
            "remaining": "import FIND from 0xa16ab1d0abde3625\n\n\n//Check the status of a fin user\npub fun main(user: Address) : [String] {\n\n\tlet account=getAccount(user)\n\tlet leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n\tlet leases=leaseCap.borrow()?.getLeaseInformation() ?? []\n\n\tvar leasesWithBids :[String] =[]\n\tfor lease in leases {\n\t\tif lease.latestBidBy == nil {\n\t\t\tleasesWithBids.append(lease.name)\n\t\t}\n\t}\n\n\treturn leasesWithBids\n}",
            "reserveStatus": "import FIND from 0xa16ab1d0abde3625\n\n\n//Check the status of a fin user\npub fun main(user: Address) : [FIND.LeaseInformation] {\n\n\tlet account=getAccount(user)\n\tlet leaseCap = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n\tlet leases=leaseCap.borrow()?.getLeaseInformation() ?? []\n\n\tvar leasesWithBids :[FIND.LeaseInformation] =[]\n\tfor lease in leases {\n\t\tif lease.latestBidBy != nil {\n\t\t\tleasesWithBids.append(lease)\n\t\t}\n\t}\n\n\treturn leasesWithBids\n}",
            "starly": "import StarlyCard from 0x5b82f21c0edf76e3\n\npub struct MetadataCollectionItem {\n\tpub let id:UInt64\n\tpub let name: String\n\tpub let image: String\n\tpub let url: String\n\tpub let listPrice: UFix64?\n\tpub let listToken: String?\n\tpub let contentType:String\n\tpub let rarity:String\n\n\n\tinit(id:UInt64, name:String, image:String, url:String, listPrice: UFix64?, listToken:String?, contentType: String, rarity: String) {\n\t\tself.id=id\n\t\tself.name=name\n\t\tself.url=url\n\t\tself.image=image\n\t\tself.listToken=listToken\n\t\tself.listPrice=listPrice\n\t\tself.contentType=contentType\n\t\tself.rarity=rarity\n\t}\n}\n\npub fun main(address: Address) : [MetadataCollectionItem] {\n\n\n\tlet items: [MetadataCollectionItem] = []\n\tlet account=getAccount(address)\n\tlet starlyCap = account.getCapability\u003c\u0026{StarlyCard.StarlyCardCollectionPublic}\u003e(StarlyCard.CollectionPublicPath)\n\tif starlyCap.check() {\n\t\tlet collection = starlyCap.borrow()!\n\t\tfor id in collection.getIDs() {\n\t\t\tlet nft = collection.borrowStarlyCard(id: id)!\n\n\t\t\tlet url=\"https://starly.io/c/\".concat(nft.starlyID)\n\t\t\tlet item = MetadataCollectionItem(\n\t\t\t\tid: id,\n\t\t\t\tname: \"Starly #\".concat(id.toString()),\n\t\t\t\timage: url.concat(\".json\"),\n\t\t\t\turl: url,\n\t\t\t\tlistPrice: nil,\n\t\t\t\tlistToken: nil,\n\t\t\t\tcontentType: \"json/starly\",\n\t\t\t\trarity: \"\"\n\t\t\t)\n\n\t\t\titems.append(item)\n\t\t}\n\t}\n\treturn items\n\n}",
            "status": "import FIND from 0xa16ab1d0abde3625\nimport Profile from 0xa16ab1d0abde3625\n\n//Check the status of a fin user\npub fun main(name: String) :  \u0026{Profile.Public}? {\n    return FIND.lookup(name)\n}"
         },
         "transactions": {
            "addCuratedCollection": "transaction(name: String, items: [String]) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet path=/storage/FindCuratedCollections\n\t\tlet publicPath=/public/FindCuratedCollections\n\n\t\tvar collections : {String: [String]} = {}\n\t\tif account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n\t\t\t collections=account.load\u003c{String: [String]}\u003e(from:path)!\n\t\t}\n\t\tcollections[name] = items\n\t\taccount.save(collections, to: path)\n\t\tlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n\t\tif !link.check() {\n\t\t\taccount.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n\t\t}\n\t}\n}",
            "bid": "import FIND from 0xa16ab1d0abde3625\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\t \n\t\tlet fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount) as! @FUSD.Vault\n\t\tlet bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)!\n\t\tbids.bid(name: name, vault: \u003c- vault)\n\n\t}\n}",
            "bidProfile": "import FIND from 0xa16ab1d0abde3625\nimport FungibleToken from 0x9a0766d93b6608b7\nimport Profile from 0xa16ab1d0abde3625\nimport FUSD from 0xe223d8a629e49c68\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(account: AuthAccount) {\n\n\n\t\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\taccount.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n\t\t\taccount.save(\u003c-profile, to: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount) as! @FUSD.Vault\n\t\tlet bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)!\n\t\tbids.bid(name: name, vault: \u003c- vault)\n\n\t}\n}",
            "cancelAuction": "import FIND from 0xa16ab1d0abde3625\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.cancel(name)\n\t\tfinLeases.delistAuction(name)\n\n\t}\n}",
            "cancelBid": "import FIND from 0xa16ab1d0abde3625\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\t\tlet bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)!\n\t\tbids.cancelBid(name)\n\t}\n}",
            "createCharity": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport CharityNFT from 0xa16ab1d0abde3625\n\n//This transaction will prepare the art collection\ntransaction() {\n\tprepare(account: AuthAccount) {\n\n\t\tlet stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t\tif !stdCap.check() {\n\t\t\taccount.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n\t\t\taccount.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\t\tif !charityCap.check() {\n\t\t\taccount.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\t}\n}",
            "createProfile": "import FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport FlowToken from 0x7e60df042a9c0868\nimport FIND from 0xa16ab1d0abde3625\nimport Profile from 0xa16ab1d0abde3625\n\n\n//really not sure on how to input links here.)\ntransaction(name: String) {\n\tprepare(acct: AuthAccount) {\n\t\t//if we do not have a profile it might be stored under a different address so we will just remove it\n\t\tlet profileCap = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif profileCap.check() {\n\t\t\treturn \n\t\t}\n\n\t\tlet profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n\n\t\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\tacct.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet fusdWallet=Profile.Wallet(\n\t\t\tname:\"FUSD\", \n\t\t\treceiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver),\n\t\t\tbalance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance),\n\t\t\taccept: Type\u003c@FUSD.Vault\u003e(),\n\t\t\tnames: [\"fusd\", \"stablecoin\"]\n\t\t)\n\n\t\tprofile.addWallet(fusdWallet)\n\n\n\t\tlet flowWallet=Profile.Wallet(\n\t\t\tname:\"Flow\", \n\t\t\treceiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\tbalance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\tnames: [\"flow\"]\n\t\t)\n\t\tprofile.addWallet(flowWallet)\n\t\tlet leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n\n\t\tlet bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\t\tprofile.addCollection(Profile.ResourceCollection( \"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n\t\tacct.save(\u003c-profile, to: Profile.storagePath)\n\t\tacct.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\tacct.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\n\t}\n}",
            "delistSale": "import FIND from 0xa16ab1d0abde3625\n\ntransaction(name: String) {\n\tprepare(acct: AuthAccount) {\n\t\tlet finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.delistSale(name)\n\t}\n}",
            "editProfile": "import FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport FlowToken from 0x7e60df042a9c0868\nimport FIND from 0xa16ab1d0abde3625\nimport Profile from 0xa16ab1d0abde3625\n\n\ntransaction(name:String, description: String, avatar: String, tags:[String], allowStoringFollowers: Bool, links: [{String: String}]) {\n\tprepare(acct: AuthAccount) {\n\n\t\tlet profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\n\t\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\tacct.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\n\t\tvar hasFusdWallet=false\n\t\tvar hasFlowWallet=false\n\t\tlet wallets=profile.getWallets()\n\t\tfor wallet in wallets {\n\t\t\tif wallet.name==\"FUSD\" {\n\t\t\t\thasFusdWallet=true\n\t\t\t}\n\n\t\t\tif wallet.name ==\"Flow\" {\n\t\t\t\thasFlowWallet=true\n\t\t\t}\n\t\t}\n\n\t\tif !hasFlowWallet {\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\t\tprofile.addWallet(flowWallet)\n\t\t}\n\n\t\tif !hasFusdWallet {\n\t\t\tlet fusdWallet=Profile.Wallet(\n\t\t\t\tname:\"FUSD\", \n\t\t\t\treceiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver),\n\t\t\t\tbalance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance),\n\t\t\t\taccept: Type\u003c@FUSD.Vault\u003e(),\n\t\t\t\tnames: [\"fusd\", \"stablecoin\"]\n\t\t\t)\n\t\t\tprofile.addWallet(fusdWallet)\n\t\t}\n\n\t\tprofile.setName(name)\n\t\tprofile.setDescription(description)\n\t\tprofile.setAvatar(avatar)\n\n\t\tlet existingTags=profile.setTags(tags)\n\n\t\tlet oldLinks=profile.getLinks()\n\n\t\tfor link in links {\n\t\t\tif !link.containsKey(\"title\") {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tif link[\"remove\"] == \"true\" {\n\t\t\t\tprofile.removeLink(link[\"title\"]!)\t\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tprofile.addLink(Profile.Link(title: link[\"title\"]!, type: link[\"type\"]!, url: link[\"url\"]!))\n\t\t}\n\t}\n}",
            "fillUpTheChest": "// Mainnet\nimport FungibleToken from 0xf233dcee88fe0abe\nimport FUSD from 0x3c5959b568896393\n\n// Testnet\n// import FungibleToken from 0x9a0766d93b6608b7\n// import FUSD from 0xe223d8a629e49c68\n\ntransaction() {\n\n\t// The Vault resource that holds the tokens that are being transfered\n\tlet sentVault: @FungibleToken.Vault\n\n\tprepare(signer: AuthAccount) {\n\t\t// Get a reference to the signer's stored vault\n\t\tlet vaultRef = signer.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault)\n\t\t?? panic(\"Could not borrow reference to the owner's Vault!\")\n\n\t\t// Withdraw tokens from the signer's stored vault\n\t\tself.sentVault \u003c- vaultRef.withdraw(amount: vaultRef.balance)\n\t}\n\n\texecute {\n\n\t\tlet recipient: Address = 0x936851d3e331acd4\n\t\t// Get the recipient's public account object\n\t\tlet recipientAccount = getAccount(recipient)\n\n\t\t// Get a reference to the recipient's Receiver\n\t\tlet receiverRef = recipientAccount.getCapability(/public/fusdReceiver)!.borrow\u003c\u0026{FungibleToken.Receiver}\u003e()\n\t\t?? panic(\"Could not borrow receiver reference to the recipient's Vault\")\n\n\t\t// Deposit the withdrawn tokens in the recipient's receiver\n\t\treceiverRef.deposit(from: \u003c-self.sentVault)\n\t}\n}",
            "fulfill": "import FIND from 0xa16ab1d0abde3625\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.fulfill(name)\n\n\t}\n}",
            "fulfillAuction": "import FIND from 0xa16ab1d0abde3625\n\ntransaction(owner: Address, name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet leaseCollection = getAccount(owner).getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tleaseCollection.borrow()!.fulfillAuction(name)\n\n\t}\n}",
            "fulfillAuctionBidder": "import FIND from 0xa16ab1d0abde3625\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport Profile from 0xa16ab1d0abde3625\n\ntransaction(owner: Address, name: String) {\n\tprepare(acct: AuthAccount) {\n\n\n\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\tacct.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n\t\t\tacct.save(\u003c-profile, to: Profile.storagePath)\n\t\t\tacct.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\tacct.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tlet leaseCollectionOwner = getAccount(owner).getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tleaseCollectionOwner.borrow()!.fulfillAuction(name)\n\n\t}\n}",
            "increaseBid": "import FIND from 0xa16ab1d0abde3625\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\t\n\t\tlet fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount) as! @FUSD.Vault\n\t\tlet bids = account.borrow\u003c\u0026FIND.BidCollection\u003e(from: FIND.BidStoragePath)!\n\t\tbids.increaseBid(name: name, vault: \u003c- vault)\n\n\t}\n}",
            "listForAuction": "import FIND from 0xa16ab1d0abde3625\n\ntransaction(name: String, auctionStartPrice: UFix64, auctionReservePrice: UFix64, auctionDuration: UFix64, auctionExtensionOnLateBid: UFix64) {\n\tprepare(acct: AuthAccount) {\n\t\tlet finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.listForAuction(name: name, auctionStartPrice: auctionStartPrice, auctionReservePrice: auctionReservePrice, auctionDuration: auctionDuration,  auctionExtensionOnLateBid: auctionExtensionOnLateBid)\n\n\t}\n}",
            "listForSale": "import FIND from 0xa16ab1d0abde3625\n\ntransaction(name: String, directSellPrice:UFix64) {\n\tprepare(acct: AuthAccount) {\n\t\tlet finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.listForSale(name: name,  directSellPrice:directSellPrice)\n\t}\n}",
            "moveNameToAddress": "import FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport FlowToken from 0x7e60df042a9c0868\nimport Profile from 0xa16ab1d0abde3625\nimport FIND from 0xa16ab1d0abde3625\n\n\ntransaction(name: String, receiverAddress:Address) {\n\n\n\tlet receiverAddress:Address\n\tlet sender : \u0026FIND.LeaseCollection\n\n\tprepare(acct: AuthAccount) {\n\t\tself.sender= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tself.receiverAddress=receiverAddress\n\t} \n\n\texecute {\n\t\tlet receiver=getAccount(self.receiverAddress)\n\t\tlet receiverLease = receiver.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tlet receiverProfile = receiver.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n\t\tif !receiverLease.check() || !receiverProfile.check() {\n\t\t\tpanic(\"Not a valid FIND user\")\n\t\t}\n\n\t\tself.sender.move(name:name, profile:receiverProfile, to: receiverLease)\n\t}\n}",
            "moveNameToName": "import FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport FlowToken from 0x7e60df042a9c0868\nimport Profile from 0xa16ab1d0abde3625\nimport FIND from 0xa16ab1d0abde3625\n\n\ntransaction(name: String, receiverName: String) {\n\n\n\tlet receiverAddress:Address\n\tlet sender : \u0026FIND.LeaseCollection\n\n\tprepare(acct: AuthAccount) {\n\n\t\tself.sender= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tself.receiverAddress=FIND.lookupAddress(receiverName) ?? panic(\"cannot resolve address\")\n\n\t} \n\n\texecute {\n\t\tlet receiver=getAccount(self.receiverAddress)\n\t\tlet receiverLease = receiver.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tlet receiverProfile = receiver.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n\t\tif !receiverLease.check() || !receiverProfile.check() {\n\t\t\tpanic(\"Not a valid FIND user\")\n\t\t}\n\n\t\tself.sender.move(name:name, profile:receiverProfile, to: receiverLease)\n\t}\n\n\n\n}",
            "register": "import FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport FlowToken from 0x7e60df042a9c0868\nimport Profile from 0xa16ab1d0abde3625\nimport FIND from 0xa16ab1d0abde3625\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(acct: AuthAccount) {\n\n\t\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\tacct.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\tacct.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\n\t\t}\n\n\t\tlet bidCollection = acct.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\tacct.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\tacct.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profile \u003c-Profile.createUser(name:name, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:acct.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:acct.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\t\t\tprofile.setFindName(name)\n\t\t\tprofile.addWallet(fusdWallet)\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n\t\t\tacct.save(\u003c-profile, to: Profile.storagePath)\n\t\t\tacct.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\tacct.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tlet price=FIND.calculateCost(name)\n\t\tif price != amount {\n\t\t\tpanic(\"Calculated cost does not match expected cost\")\n\t\t}\n\t\tlog(\"The cost for registering this name is \".concat(price.toString()))\n\n\t\tlet vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\n\t\tlet payVault \u003c- vaultRef.withdraw(amount: price) as! @FUSD.Vault\n\n\t\tlet leases=acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)!\n\t\tleases.register(name: name, vault: \u003c- payVault)\n\n\t}\n}",
            "registerGift": "import FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport FlowToken from 0x7e60df042a9c0868\nimport Profile from 0xa16ab1d0abde3625\nimport FIND from 0xa16ab1d0abde3625\n\ntransaction(name: String, amount: UFix64, recipient: Address) {\n\tprepare(acct: AuthAccount) {\n\n\t\tlet price=FIND.calculateCost(name)\n\t\tif price != amount {\n\t\t\tpanic(\"Calculated cost does not match expected cost\")\n\t\t}\n\t\tlog(\"The cost for registering this name is \".concat(price.toString()))\n\n\t\tlet vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet payVault \u003c- vaultRef.withdraw(amount: price) as! @FUSD.Vault\n\n\t\tlet leases=acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from: FIND.LeaseStoragePath)!\n\t\tleases.register(name: name, vault: \u003c- payVault)\n\n\t\tlet receiver = getAccount(recipient)\n\t\tlet receiverLease = receiver.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tlet receiverProfile = receiver.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !receiverLease.check() {\n\t\t\tpanic(\"Receiver is not a find user\")\n\t\t}\n\t\tleases.move(name: name, profile: receiverProfile, to: receiverLease)\n\t}\n}",
            "rejectDirectOffer": "import FIND from 0xa16ab1d0abde3625\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.cancel(name)\n\n\t}\n}",
            "removeCurratedCollection": "transaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet path=/storage/FindCuratedCollections\n\t\tlet publicPath=/public/FindCuratedCollections\n\n\t\tvar collections : {String: [String]} = {}\n\t\tif account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n\t\t\t collections=account.load\u003c{String: [String]}\u003e(from:path)!\n\t\t}\n\t\tcollections.remove(key: name)\n\t\taccount.save(collections, to: path)\n\t\tlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n\t\tif !link.check() {\n\t\t\taccount.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n\t\t}\n\t}\n}",
            "removeProfile": "import Profile from 0xa16ab1d0abde3625\nimport FIND from 0xa16ab1d0abde3625\n\ntransaction() {\n\tprepare(acct: AuthAccount) {\n\t\t\tacct.unlink(Profile.publicPath)\n\t\t\tdestroy \u003c- acct.load\u003c@AnyResource\u003e(from:Profile.storagePath)\n\n\t\t\tacct.unlink(FIND.BidPublicPath)\n\t\t\tdestroy \u003c- acct.load\u003c@AnyResource\u003e(from:FIND.BidStoragePath)\n\n\t\t\tacct.unlink(FIND.LeasePublicPath)\n\t\t\tdestroy \u003c- acct.load\u003c@AnyResource\u003e(from:FIND.LeaseStoragePath)\n\t}\n}",
            "removeRelatedAccount": "import RelatedAccounts from 0xa16ab1d0abde3625\n\n\ntransaction(name: String){\n\tprepare(account: AuthAccount) {\n\n\t\tlet cap = account.getCapability\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath)\n\t\tif !cap.check() {\n\t\t\tlet relatedAccounts \u003c- RelatedAccounts.createEmptyAccounts()\n\t\t\taccount.save(\u003c- relatedAccounts, to: RelatedAccounts.storagePath)\n\t\t\taccount.link\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath, target: RelatedAccounts.storagePath)\n\t\t}\n\n\t\tlet relatedAccounts =account.borrow\u003c\u0026RelatedAccounts.Accounts\u003e(from:RelatedAccounts.storagePath)!\n\t\trelatedAccounts.deleteAccount(name: name)\n\t}\n}",
            "renew": "import FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport Profile from 0xa16ab1d0abde3625\nimport FIND from 0xa16ab1d0abde3625\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(acct: AuthAccount) {\n\n\t\tlet profileCap = acct.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\n\t\tlet price=FIND.calculateCost(name)\n\t\tif amount != price {\n\t\t\tpanic(\"expected renew cost is not the same as calculated renew cost\")\n\t\t}\n\t\tlet vaultRef = acct.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet payVault \u003c- vaultRef.withdraw(amount: price) as! @FUSD.Vault\n\n\t\tlet finLeases= acct.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tlet finToken= finLeases.borrow(name)\n\t\tfinToken.extendLease(\u003c- payVault)\n\t}\n}",
            "sendCharity": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport CharityNFT from 0xa16ab1d0abde3625\n\n//mint an art and add it to a users collection\ntransaction(\n\tid: UInt64,\n\trecipient: Address\n) {\n\tlet receiverCap: Capability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e\n\tlet charityCollection: \u0026NonFungibleToken.Collection\n\n\tprepare(account: AuthAccount) {\n\t\tself.charityCollection =account.borrow\u003c\u0026NonFungibleToken.Collection\u003e(from: CharityNFT.CollectionStoragePath)!\n\t\tself.receiverCap= getAccount(recipient).getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t}\n\n\texecute {\n\t\tlet nft \u003c- self.charityCollection.withdraw(withdrawID: id)\n\t\tself.receiverCap.borrow()!.deposit(token: \u003c- nft)\n\t}\n}",
            "sendFT": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport FlowToken from 0x7e60df042a9c0868\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport Profile from 0xa16ab1d0abde3625\nimport Sender from 0xa16ab1d0abde3625\nimport FIND from 0xa16ab1d0abde3625\nimport CharityNFT from 0xa16ab1d0abde3625\n\n\ntransaction(name: String, amount: UFix64, type: String) {\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t\tif !stdCap.check() {\n\t\t\taccount.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n\t\t\taccount.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\t\tif !charityCap.check() {\n\t\t\taccount.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t  let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\taccount.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profileName = account.address.toString()\n\n\t\t\tlet profile \u003c-Profile.createUser(name:profileName, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n\t\t\taccount.save(\u003c-profile, to: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tif account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n\t\t\taccount.save(\u003c- Sender.create(), to: Sender.storagePath)\n\t\t}\n\n\t\tlet token =account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n\n\n\t\tif type == \"fusd\" {\n\t\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\t\tlet vault \u003c- vaultRef.withdraw(amount: amount)\n\t\t\tFIND.depositWithTagAndMessage(to: name, message: \"\", tag: \"find\", vault: \u003c- vault, from: token)\n\t\t\treturn \n\t\t}\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount)\n\t\tFIND.depositWithTagAndMessage(to: name, message: \"\", tag: \"find\", vault: \u003c- vault, from: token)\n\t}\n\n}",
            "sendFlowWithMessage": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport FlowToken from 0x7e60df042a9c0868\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport Profile from 0xa16ab1d0abde3625\nimport FIND from 0xa16ab1d0abde3625\nimport CharityNFT from 0xa16ab1d0abde3625\n\ntransaction(name: String, amount: UFix64, message:String) {\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t\tif !stdCap.check() {\n\t\t\taccount.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n\t\t\taccount.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\t\tif !charityCap.check() {\n\t\t\taccount.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\taccount.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profileName = account.address.toString()\n\n\t\t\tlet profile \u003c-Profile.createUser(name:profileName, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n\t\t\taccount.save(\u003c-profile, to: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tlet profile =account.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\n\n\t\tlet strLength = amount.toString().length\n\t\tlet amountString = amount.toString().slice(from: 0, upTo: strLength-6)\n\t\tprofile.verify(profile.getName().concat(\" sent \").concat(amountString).concat(\" Flow with message:\").concat(message))\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tFIND.deposit(to: name, from: \u003c- vaultRef.withdraw(amount: amount))\n\t}\n}",
            "sendFlowWithTagAndMessage": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport FlowToken from 0x7e60df042a9c0868\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport Profile from 0xa16ab1d0abde3625\nimport Sender from 0xa16ab1d0abde3625\nimport FIND from 0xa16ab1d0abde3625\nimport CharityNFT from 0xa16ab1d0abde3625\n\ntransaction(name: String, amount: UFix64, message:String, tag: String) {\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t\tif !stdCap.check() {\n\t\t\taccount.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n\t\t\taccount.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\t\tif !charityCap.check() {\n\t\t\taccount.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t  let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\taccount.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profileName = account.address.toString()\n\n\t\t\tlet profile \u003c-Profile.createUser(name:profileName, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n\t\t\taccount.save(\u003c-profile, to: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tif account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n\t\t\taccount.save(\u003c- Sender.create(), to: Sender.storagePath)\n\t\t}\n\n\t\tlet token =account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FlowToken.Vault\u003e(from: /storage/flowTokenVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount)\n\t\tFIND.depositWithTagAndMessage(to: name, message: message, tag: tag, vault: \u003c- vault, from: token)\n\t}\n\n}",
            "sendFusdWithTagAndMessage": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport FlowToken from 0x7e60df042a9c0868\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport Profile from 0xa16ab1d0abde3625\nimport Sender from 0xa16ab1d0abde3625\nimport FIND from 0xa16ab1d0abde3625\nimport CharityNFT from 0xa16ab1d0abde3625\n\ntransaction(name: String, amount: UFix64, message:String, tag: String) {\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t\tif !stdCap.check() {\n\t\t\taccount.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n\t\t\taccount.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\t\tif !charityCap.check() {\n\t\t\taccount.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t  let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\taccount.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profileName = account.address.toString()\n\n\t\t\tlet profile \u003c-Profile.createUser(name:profileName, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n\t\t\taccount.save(\u003c-profile, to: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tif account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath) == nil {\n\t\t\taccount.save(\u003c- Sender.create(), to: Sender.storagePath)\n\t\t}\n\n\t\tlet token =account.borrow\u003c\u0026Sender.Token\u003e(from: Sender.storagePath)!\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tlet vault \u003c- vaultRef.withdraw(amount: amount)\n\t\tFIND.depositWithTagAndMessage(to: name, message: message, tag: tag, vault: \u003c- vault, from: token)\n\t}\n\n}",
            "sendFusdWithmessage": "import NonFungibleToken from 0x631e88ae7f1d7c20\nimport FlowToken from 0x7e60df042a9c0868\nimport FungibleToken from 0x9a0766d93b6608b7\nimport FUSD from 0xe223d8a629e49c68\nimport Profile from 0xa16ab1d0abde3625\nimport FIND from 0xa16ab1d0abde3625\nimport CharityNFT from 0xa16ab1d0abde3625\n\ntransaction(name: String, amount: UFix64, message:String) {\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet stdCap= account.getCapability\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath)\n\t\tif !stdCap.check() {\n\t\t\taccount.save\u003c@NonFungibleToken.Collection\u003e(\u003c- CharityNFT.createEmptyCollection(), to: CharityNFT.CollectionStoragePath)\n\t\t\taccount.link\u003c\u0026{NonFungibleToken.CollectionPublic}\u003e(CharityNFT.CollectionPublicPath, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t\tlet charityCap = account.getCapability\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection)\n\t\tif !charityCap.check() {\n\t\t\taccount.link\u003c\u0026{CharityNFT.CollectionPublic}\u003e(/public/findCharityNFTCollection, target: CharityNFT.CollectionStoragePath)\n\t\t}\n\n\t  let fusdReceiver = account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd \u003c- FUSD.createEmptyVault()\n\t\t\taccount.save(\u003c- fusd, to: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Receiver}\u003e( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\taccount.link\u003c\u0026FUSD.Vault{FungibleToken.Balance}\u003e( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet leaseCollection = account.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(\u003c- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\t\tlet profileCap = account.getCapability\u003c\u0026{Profile.Public}\u003e(Profile.publicPath)\n\t\tif !profileCap.check() {\n\t\t\tlet profileName = account.address.toString()\n\n\t\t\tlet profile \u003c-Profile.createUser(name:profileName, createdAt: \"find\")\n\n\t\t\tlet fusdWallet=Profile.Wallet( name:\"FUSD\", receiver:fusdReceiver, balance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/fusdBalance), accept: Type\u003c@FUSD.Vault\u003e(), names: [\"fusd\", \"stablecoin\"])\n\n\t\t\tprofile.addWallet(fusdWallet)\n\n\t\t\tlet flowWallet=Profile.Wallet(\n\t\t\t\tname:\"Flow\", \n\t\t\t\treceiver:account.getCapability\u003c\u0026{FungibleToken.Receiver}\u003e(/public/flowTokenReceiver),\n\t\t\t\tbalance:account.getCapability\u003c\u0026{FungibleToken.Balance}\u003e(/public/flowTokenBalance),\n\t\t\t\taccept: Type\u003c@FlowToken.Vault\u003e(),\n\t\t\t\tnames: [\"flow\"]\n\t\t\t)\n\t\n\t\t\tprofile.addWallet(flowWallet)\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(), [\"find\", \"leases\"]))\n\t\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDBids\", bidCollection, Type\u003c\u0026FIND.BidCollection{FIND.BidCollectionPublic}\u003e(), [\"find\", \"bids\"]))\n\n\t\t\taccount.save(\u003c-profile, to: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026Profile.User{Profile.Public}\u003e(Profile.publicPath, target: Profile.storagePath)\n\t\t\taccount.link\u003c\u0026{FungibleToken.Receiver}\u003e(Profile.publicReceiverPath, target: Profile.storagePath)\n\t\t}\n\n\t\tlet profile =account.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\n\t\tlet strLength = amount.toString().length\n\t\tlet amountString = amount.toString().slice(from: 0, upTo: strLength-6)\n\t\tprofile.verify(profile.getName().concat(\" sent \").concat(amountString).concat(\" FUSD with message:\").concat(message))\n\n\t\tlet vaultRef = account.borrow\u003c\u0026FUSD.Vault\u003e(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the fusdVault!\")\n\t\tFIND.deposit(to: name, from: \u003c- vaultRef.withdraw(amount: amount))\n\n\t}\n\n}",
            "setMainName": "import Profile from 0xa16ab1d0abde3625\nimport FIND from 0xa16ab1d0abde3625\n\n\ntransaction(name: String) {\n\tprepare(acct: AuthAccount) {\n\n\t\tlet leaseCollectionOwner = acct.getCapability\u003c\u0026FIND.LeaseCollection{FIND.LeaseCollectionPublic}\u003e(FIND.LeasePublicPath)\n\n\t\tif !leaseCollectionOwner.check() {\n\t\t\tpanic(\"Not a find user\")\n\t\t}\n\n\t\tif leaseCollectionOwner.borrow()!.getLease(name) == nil {\n\t\t\tpanic(\"You do not own this lease so you cannot set it as main name\")\n\t\t}\n\n\n\t\tlet profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\t\tprofile.setFindName(name)\n\t}\n}",
            "setPrivateMode": "import Profile from 0xa16ab1d0abde3625\nimport FIND from 0xa16ab1d0abde3625\n\ntransaction(mode: Bool) {\n\tprepare(acct: AuthAccount) {\n\t\tlet profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\t\tprofile.setPrivateMode(mode)\n\t}\n}",
            "setProfile": "import Profile from 0xa16ab1d0abde3625\n\n\ntransaction(avatar: String) {\n\tprepare(acct: AuthAccount) {\n\t\tlet profile =acct.borrow\u003c\u0026Profile.User\u003e(from:Profile.storagePath)!\n\t\tprofile.setAvatar(avatar)\n\t}\n}",
            "setRelatedAccount": "import RelatedAccounts from 0xa16ab1d0abde3625\n\n\ntransaction(name: String, address: Address) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet cap = account.getCapability\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath)\n\t\tif !cap.check() {\n\t\t\tlet relatedAccounts \u003c- RelatedAccounts.createEmptyAccounts()\n\t\t\taccount.save(\u003c- relatedAccounts, to: RelatedAccounts.storagePath)\n\t\t\taccount.link\u003c\u0026RelatedAccounts.Accounts{RelatedAccounts.Public}\u003e(RelatedAccounts.publicPath, target: RelatedAccounts.storagePath)\n\t\t}\n\n\t\tlet relatedAccounts =account.borrow\u003c\u0026RelatedAccounts.Accounts\u003e(from:RelatedAccounts.storagePath)!\n\t\trelatedAccounts.setFlowAccount(name: name, address: address)\n\t}\n}",
            "startAuction": "import FIND from 0xa16ab1d0abde3625\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet finLeases= account.borrow\u003c\u0026FIND.LeaseCollection\u003e(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.startAuction(name)\n\n\t}\n}",
            "storeCuratedCollections": "transaction(collections: {String :  [String]}) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet path=/storage/FindCuratedCollections\n\t\tlet publicPath=/public/FindCuratedCollections\n\n\t\tif account.borrow\u003c\u0026{String: [String]}\u003e(from:path) != nil {\n\t\t\t account.load\u003c{String: [String]}\u003e(from:path)\n\t\t}\n\t\taccount.save(collections, to: path)\n\n\t\tlet link = account.getCapability\u003c\u0026{String: [String]}\u003e(publicPath)\n\t\tif !link.check() {\n\t\t\taccount.link\u003c\u0026{String: [String]}\u003e( publicPath, target: path)\n\t\t}\n\t}\n}"
         }
      }
   }
}
