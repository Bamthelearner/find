{"transactions":{"bid":"import FIND from 0xFIND\nimport FungibleToken from 0xFungibleToken\nimport FUSD from 0xFUSD\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet vaultRef = account.borrow<&FUSD.Vault>(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the owner's Vault!\")\n\t\t \n\t\tlet fusdReceiver = account.getCapability<&{FungibleToken.Receiver}>(/public/fusdReceiver)\n\n\t\tlet leaseCollection = account.getCapability<&{FIND.LeaseCollectionPublic}>(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(<- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link<&{FIND.LeaseCollectionPublic}>( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability<&{FIND.BidCollectionPublic}>(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(<- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link<&{FIND.BidCollectionPublic}>( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\n\t\tlet vault <- vaultRef.withdraw(amount: amount) as! @FUSD.Vault\n\t\tlet bids = account.borrow<&FIND.BidCollection>(from: FIND.BidStoragePath)!\n\t\tbids.bid(name: name, vault: <- vault)\n\n\t}\n}\n","cancelAuction":"import FIND from 0xFIND\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet finLeases= account.borrow<&FIND.LeaseCollection>(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.cancel(name)\n\n\t}\n}\n","cancelBid":"import FIND from 0xFIND\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\t\tlet bids = account.borrow<&FIND.BidCollection>(from: FIND.BidStoragePath)!\n\t\tbids.cancelBid(name)\n\t}\n}\n","clock":"import FIND from 0xFIND\n\ntransaction(clock: UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet adminClient=account.borrow<&FIND.AdminProxy>(from: FIND.AdminProxyStoragePath)!\n\t\tadminClient.advanceClock(clock)\n\n\t}\n}\n","create_profile":"import FungibleToken from 0xFungibleToken\nimport FUSD from 0xFUSD\nimport FIND from 0xFIND\nimport Profile from 0xProfile\n\n\ntransaction(name: String, description: String, names:[String], allowStoringFollowers: Bool) {\n\tprepare(acct: AuthAccount) {\n\n\t\tlet profile <-Profile.createUser(name:name, description: description, allowStoringFollowers:allowStoringFollowers, names:names)\n\n\t\t//Add exising FUSD or create a new one and add it\n\t\tlet fusdReceiver = acct.getCapability<&{FungibleToken.Receiver}>(/public/fusdReceiver)\n\t\tif !fusdReceiver.check() {\n\t\t\tlet fusd <- FUSD.createEmptyVault()\n\t\t\tacct.save(<- fusd, to: /storage/fusdVault)\n\t\t\tacct.link<&FUSD.Vault{FungibleToken.Receiver}>( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\tacct.link<&FUSD.Vault{FungibleToken.Balance}>( /public/fusdBalance, target: /storage/fusdVault)\n\n\t\t\tlet fusdWallet=Profile.Wallet(\n\t\t\t\tname:\"FUSD\", \n\t\t\t\treceiver:acct.getCapability<&{FungibleToken.Receiver}>(/public/fusdReceiver),\n\t\t\t\tbalance:acct.getCapability<&{FungibleToken.Balance}>(/public/fusdBalance),\n\t\t\t\taccept: Type<@FUSD.Vault>(),\n\t\t\t\tnames: [\"fusd\", \"stablecoin\"]\n\t\t\t)\n\n\t\t\tprofile.addWallet(fusdWallet)\n\n\t\t}\n\n\t\tlet leaseCollection = acct.getCapability<&{FIND.LeaseCollectionPublic}>(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\tacct.save(<- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\tacct.link<&{FIND.LeaseCollectionPublic}>( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\t\tprofile.addCollection(Profile.ResourceCollection(\"FINDLeases\",leaseCollection, Type<&{FIND.LeaseCollectionPublic}>(), [\"find\", \"leases\"]))\n\n\t\tlet bidCollection = acct.getCapability<&{FIND.BidCollectionPublic}>(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\tacct.save(<- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\tacct.link<&{FIND.BidCollectionPublic}>( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\t\tprofile.addCollection(Profile.ResourceCollection( \"FINDBids\", bidCollection, Type<&{FIND.BidCollectionPublic}>(), [\"find\", \"bids\"]))\n\n\t\tacct.save(<-profile, to: Profile.storagePath)\n\t\tacct.link<&Profile.User{Profile.Public}>(Profile.publicPath, target: Profile.storagePath)\n\n\t\tlet p =acct.borrow<&Profile.User>(from:Profile.storagePath)!\n\t\tp.verify(\"test\")\n\t}\n}\n","fullfill":"import FIND from 0xFIND\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet finLeases= account.borrow<&FIND.LeaseCollection>(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.fullfill(name)\n\n\t}\n}\n","fullfill_auction":"import FIND from 0xFIND\n\ntransaction(owner: Address, name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet leaseCollection = getAccount(owner).getCapability<&{FIND.LeaseCollectionPublic}>(FIND.LeasePublicPath)\n\t\tleaseCollection.borrow()!.fullfillAuction(name)\n\n\t}\n}\n","increaseBid":"import FIND from 0xFIND\nimport FungibleToken from 0xFungibleToken\nimport FUSD from 0xFUSD\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet vaultRef = account.borrow<&FUSD.Vault>(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the owner's Vault!\")\n\t\tlet seller=FIND.lookup(name)!.owner\n\t\t\n\t\tlet fusdReceiver = account.getCapability<&{FungibleToken.Receiver}>(/public/fusdReceiver)\n\n\t\tlet leaseCollection = account.getCapability<&{FIND.LeaseCollectionPublic}>(FIND.LeasePublicPath)\n\t\tif !leaseCollection.check() {\n\t\t\taccount.save(<- FIND.createEmptyLeaseCollection(), to: FIND.LeaseStoragePath)\n\t\t\taccount.link<&{FIND.LeaseCollectionPublic}>( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet bidCollection = account.getCapability<&{FIND.BidCollectionPublic}>(FIND.BidPublicPath)\n\t\tif !bidCollection.check() {\n\t\t\taccount.save(<- FIND.createEmptyBidCollection(receiver: fusdReceiver, leases: leaseCollection), to: FIND.BidStoragePath)\n\t\t\taccount.link<&{FIND.BidCollectionPublic}>( FIND.BidPublicPath, target: FIND.BidStoragePath)\n\t\t}\n\n\n\t\tlet vault <- vaultRef.withdraw(amount: amount) as! @FUSD.Vault\n\t\tlet bids = account.borrow<&FIND.BidCollection>(from: FIND.BidStoragePath)!\n\t\tbids.increaseBid(name: name, vault: <- vault)\n\n\t}\n}\n","janitor":"\nimport FIND from 0xFIND\n\ntransaction(name: String) {\n\n    prepare(account: AuthAccount) {\n       FIND.janitor(name)\n    }\n}\n \n","mint_fusd":"\n\nimport FungibleToken from 0xFungibleToken\nimport FUSD from 0xFUSD\n\ntransaction(recipient: Address, amount: UFix64) {\n\tlet tokenAdmin: &FUSD.Administrator\n\tlet tokenReceiver: &{FungibleToken.Receiver}\n\n\tprepare(signer: AuthAccount) {\n\n\t\tself.tokenAdmin = signer\n\t\t.borrow<&FUSD.Administrator>(from: /storage/fusdAdmin)\n\t\t?? panic(\"Signer is not the token admin\")\n\n\t\tself.tokenReceiver = getAccount(recipient)\n\t\t.getCapability(/public/fusdReceiver)\n\t\t.borrow<&{FungibleToken.Receiver}>()\n\t\t?? panic(\"Unable to borrow receiver reference\")\n\t}\n\n\texecute {\n\n\n\n\t\tlet minter <- self.tokenAdmin.createNewMinter()\n\t\tlet mintedVault <- minter.mintTokens(amount: amount)\n\n\t\tself.tokenReceiver.deposit(from: <-mintedVault)\n\n\t\tdestroy minter\n\t}\n}\n","register":"import FungibleToken from 0xFungibleToken\nimport FUSD from 0xFUSD\nimport Profile from 0xProfile\nimport FIND from 0xFIND\n\n\ntransaction(name: String) {\n\tprepare(acct: AuthAccount) {\n\n\t\tlet profileCap = acct.getCapability<&{Profile.Public}>(Profile.publicPath)\n\n\t\tlet price=FIND.calculateCost(name)\n\t\tlog(\"The cost for registering this name is \".concat(price.toString()))\n\n\t\tlet vaultRef = acct.borrow<&FUSD.Vault>(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the owner's Vault!\")\n\t\tlet payVault <- vaultRef.withdraw(amount: price) as! @FUSD.Vault\n\n\t\tlet leaseCollectionCap=acct.getCapability<&{FIND.LeaseCollectionPublic}>(FIND.LeasePublicPath)\n\t\tif !leaseCollectionCap.check() {\n\t\t\tlet finLeases <- FIND.createEmptyLeaseCollection()\n\t\t\tacct.save(<- finLeases, to: FIND.LeaseStoragePath)\n\t\t\tacct.link<&{FIND.LeaseCollectionPublic}>( FIND.LeasePublicPath, target: FIND.LeaseStoragePath)\n\t\t}\n\n\t\tlet leases=acct.borrow<&FIND.LeaseCollection>(from: FIND.LeaseStoragePath)!\n\t\tleases.register(name: name, vault: <- payVault)\n\n\t}\n}\n","registerAdmin":"\n\nimport FUSD from 0xFUSD\nimport FIND from 0xFIND\nimport Profile from 0xProfile\nimport FungibleToken from 0xFungibleToken\n\ntransaction(name: String, user: Address) {\n\n\tprepare(account: AuthAccount) {\n\n\t\tlet userAccount=getAccount(user)\n\t\tlet profileCap = userAccount.getCapability<&{Profile.Public}>(Profile.publicPath)\n\t\tlet leaseCollectionCap=userAccount.getCapability<&{FIND.LeaseCollectionPublic}>(FIND.LeasePublicPath)\n\n\t\tlet wallet=account.getCapability<&{FungibleToken.Receiver}>(/public/fusdReceiver)\n\t\tlet adminClient=account.borrow<&FIND.AdminProxy>(from: FIND.AdminProxyStoragePath)!\n\n\t\tlet vaultRef = account.borrow<&FUSD.Vault>(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the owner's Vault!\")\n\t\tlet payVault <- vaultRef.withdraw(amount: 5.0) as! @FUSD.Vault\n\n\t\tadminClient.register(name: name, vault: <- payVault, profile: profileCap, leases: leaseCollectionCap)\n\t}\n}\n\n","renew":"import FungibleToken from 0xFungibleToken\nimport FUSD from 0xFUSD\nimport Profile from 0xProfile\nimport FIND from 0xFIND\n\n\ntransaction(name: String) {\n\tprepare(acct: AuthAccount) {\n\n\t\tlet profileCap = acct.getCapability<&{Profile.Public}>(Profile.publicPath)\n\n\t\tlet price=FIND.calculateCost(name)\n\t\tlog(\"The cost for registering this name is \".concat(price.toString()))\n\n\t\tlet vaultRef = acct.borrow<&FUSD.Vault>(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the owner's Vault!\")\n\t\tlet payVault <- vaultRef.withdraw(amount: price) as! @FUSD.Vault\n\n\t\tlet finLeases= acct.borrow<&FIND.LeaseCollection>(from:FIND.LeaseStoragePath)!\n\t\tlog(\"STATUS PRE\")\n\t\tlet finToken= finLeases.borrow(name)\n\t\tlog(finToken.getLeaseExpireTime().toString())\n\t\tfinToken.extendLease(<- payVault)\n\t\tlog(\"STATUS POST\")\n\t\tlog(finToken.getLeaseExpireTime().toString())\n\n\t}\n}\n","reregister":"\nimport FungibleToken from 0xFungibleToken\nimport FUSD from 0xFUSD\nimport Profile from 0xProfile\nimport FIND from 0xFIND\n\n\ntransaction(name: String) {\n\n    prepare(account: AuthAccount) {\n\n\n        let profileCap = account.getCapability<&{Profile.Public}>(Profile.publicPath)\n\n        let price=FIND.calculateCost(name)\n        log(\"The cost for registering this name is \".concat(price.toString()))\n\n        let vaultRef = account.borrow<&FUSD.Vault>(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the owner's Vault!\")\n        let payVault <- vaultRef.withdraw(amount: price)\n\n        FIND.register(name: name, vault: <- payVault, profile: profileCap)\n\n        log(\"STATUS POST\")\n        log(FIND.status(name))\n\n    }\n\n}\n \n","sell":"import FIND from 0xFIND\n\ntransaction(name: String, amount: UFix64) {\n\tprepare(acct: AuthAccount) {\n\n\t\tlet finLeases= acct.borrow<&FIND.LeaseCollection>(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.listForSale(name: name, amount: amount)\n\n\t}\n}\n","send":"import FUSD from 0xFUSD\nimport FIND from 0xFIND\n\ntransaction(name: String, amount: UFix64) {\n\n    prepare(account: AuthAccount) {\n        let vaultRef = account.borrow<&FUSD.Vault>(from: /storage/fusdVault) ?? panic(\"Could not borrow reference to the owner's Vault!\")\n\n        log(\"Sending \".concat(amount.toString()).concat( \" to profile with name \").concat(name))\n        FIND.deposit(to: name, from: <- vaultRef.withdraw(amount: amount))\n    }\n\n}\n \n","setup_fin_1_create_client":"\nimport \"../contracts/FIND.cdc\"\n\n//set up the adminClient in the contract that will own the network\ntransaction() {\n\n    prepare(account: AuthAccount) {\n\n        account.save(<- FIND.createAdminProxyClient(), to:FIND.AdminProxyStoragePath)\n        account.link<&{FIND.AdminProxyClient}>(FIND.AdminProxyPublicPath, target: FIND.AdminProxyStoragePath)\n\n\n    }\n}\n","setup_fin_2_register_client":"import \"../contracts/FIND.cdc\"\n\n\n//link together the administrator to the client, signed by the owner of the contract\ntransaction(ownerAddress: Address) {\n\n    //versus account\n    prepare(account: AuthAccount) {\n\n        let owner= getAccount(ownerAddress)\n        let client= owner.getCapability<&{FIND.AdminProxyClient}>(FIND.AdminProxyPublicPath)\n                .borrow() ?? panic(\"Could not borrow admin client\")\n\n        let network=account.getCapability<&FIND.Network>(FIND.NetworkPrivatePath)\n        client.addCapability(network)\n\n    }\n}\n \n","setup_fin_3_create_network":"\nimport FUSD from 0xFUSD\nimport FIND from 0xFIND\nimport FungibleToken from 0xFungibleToken\n\ntransaction(leasePeriod: UFix64) {\n\n\tprepare(account: AuthAccount) {\n\t\tlet wallet=account.getCapability<&{FungibleToken.Receiver}>(/public/fusdReceiver)\n\t\tif !wallet.check() {\n\t\t\tlet fusd <- FUSD.createEmptyVault()\n\t\t\taccount.save(<- fusd, to: /storage/fusdVault)\n\t\t\taccount.link<&FUSD.Vault{FungibleToken.Receiver}>( /public/fusdReceiver, target: /storage/fusdVault)\n\t\t\taccount.link<&FUSD.Vault{FungibleToken.Balance}>( /public/fusdBalance, target: /storage/fusdVault)\n\t\t}\n\n\t\tlet adminClient=account.borrow<&FIND.AdminProxy>(from: FIND.AdminProxyStoragePath)!\n\t\tadminClient.setWallet(wallet)\n\t\tadminClient.setPublicEnabled(true)\n\t}\n}\n\n","startAuction":"import FIND from 0xFIND\n\ntransaction(name: String) {\n\tprepare(account: AuthAccount) {\n\n\t\tlet finLeases= account.borrow<&FIND.LeaseCollection>(from:FIND.LeaseStoragePath)!\n\t\tfinLeases.startAuction(name)\n\n\t}\n}\n","status":"\nimport FIND from 0xFIND\n\ntransaction(name: String) {\n\n    prepare(account: AuthAccount) {\n        let status=FIND.status(name)\n\t\t\t\tif status.status == FIND.LeaseStatus.LOCKED {\n\t\t\t\t\tpanic(\"locked\")\n\t\t\t\t}\n\t\t\t\tif status.status == FIND.LeaseStatus.FREE {\n\t\t\t\t\tpanic(\"free\")\n\t\t\t\t}\n    }\n\n}\n \n"},"scripts":{"bid_status":"import FIND from 0xFIND\n\n//Check the status of a fin user\npub fun main(user: Address) : [FIND.BidInfo]{\n\n\tlet bidCollection = getAccount(user).getCapability<&{FIND.BidCollectionPublic}>(FIND.BidPublicPath)\n\treturn bidCollection.borrow()!.getBids()\n}\n","check_fin":"import FIND from 0xFIND\n\n\n/*\n  This script will check an address and print out its FT, NFT and Versus resources\n */\npub fun main() :UFix64 {\n\n    log(FIND.status(\"0xb\"))\n    return FIND.calculateCost(\"0xb\")\n}\n","lease_status":"import FIND from 0xFIND\n\n//Check the status of a fin user\npub fun main(user: Address) : [FIND.LeaseInformation] {\n\n\t  let leaseCollection = getAccount(user).getCapability<&{FIND.LeaseCollectionPublic}>(FIND.LeasePublicPath)\n\t\treturn leaseCollection.borrow()!.getLeaseInformation()\n}\n","lease_status_single":"import FIND from 0xFIND\n\n//Check the status of a fin user\npub fun main(name: String, user: Address) : FIND.LeaseInformation {\n\t  let leaseCollection = getAccount(user).getCapability<&{FIND.LeaseCollectionPublic}>(FIND.LeasePublicPath)\n\t\treturn leaseCollection.borrow()!.getLease(name)!\n}\n","profile":"import Profile from 0xProfile\npub fun main(address:Address) : Profile.UserProfile? {\n  return getAccount(address)\n        .getCapability<&{Profile.Public}>(Profile.publicPath)\n        .borrow()?.asProfile()\n}\n","status":"import FIND from 0xFIND\nimport Profile from 0xProfile\n\n//Check the status of a fin user\npub fun main(name: String) :  &{Profile.Public}? {\n    return FIND.lookup(name)\n}\n"},"vars":{"emulator":{"0xNonFungibleToken":"0xf8d6e0586b0a20c7","0xFUSD":"0xf8d6e0586b0a20c7","0xFungibleToken":"0xee82856bf20e2aa6","0xFlowToken":"0x0ae53cb6e3f42a79","0xFIND":"0xf8d6e0586b0a20c7","0xClock":"0xf8d6e0586b0a20c7","0xProfile":"0xf8d6e0586b0a20c7","0xDebug":"0xf8d6e0586b0a20c7"},"testnet":{"0xNonFungibleToken":"0x631e88ae7f1d7c20","0xFUSD":"0xe223d8a629e49c68","0xFungibleToken":"0x9a0766d93b6608b7","0xFlowToken":"0x7e60df042a9c0868","0xFIND":"0x8bde8952731c1f8c","0xClock":"0x8bde8952731c1f8c","0xProfile":"0x99ca04281098b33d","0xDebug":"0x8bde8952731c1f8c"},"mainnet":{"0xNonFungibleToken":null,"0xFUSD":"0x3c5959b568896393","0xFungibleToken":null,"0xFlowToken":"0x1654653399040a61","0xFIND":null,"0xClock":null,"0xProfile":"0xd796ff17107bbff6","0xDebug":null}}}